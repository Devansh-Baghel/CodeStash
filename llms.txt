Directory structure:
â””â”€â”€ CodeStash/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ todo.md
    â”œâ”€â”€ backend/
    â”‚   â”œâ”€â”€ eslint.config.mjs
    â”‚   â”œâ”€â”€ package.json
    â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”œâ”€â”€ tsup.config.ts
    â”‚   â”œâ”€â”€ .prettierignore
    â”‚   â”œâ”€â”€ public/
    â”‚   â”‚   â””â”€â”€ temp/
    â”‚   â”‚       â””â”€â”€ .gitkeep
    â”‚   â””â”€â”€ src/
    â”‚       â”œâ”€â”€ app.ts
    â”‚       â”œâ”€â”€ constants.ts
    â”‚       â”œâ”€â”€ index.ts
    â”‚       â”œâ”€â”€ controllers/
    â”‚       â”‚   â”œâ”€â”€ ai.controller.ts
    â”‚       â”‚   â”œâ”€â”€ comment.controllers.ts
    â”‚       â”‚   â”œâ”€â”€ community.controllers.ts
    â”‚       â”‚   â”œâ”€â”€ healthCheck.controller.ts
    â”‚       â”‚   â”œâ”€â”€ post.controllers.ts
    â”‚       â”‚   â”œâ”€â”€ user.controllers.ts
    â”‚       â”‚   â””â”€â”€ __tests__/
    â”‚       â”‚       â””â”€â”€ healthCheck.controller.test.ts
    â”‚       â”œâ”€â”€ db/
    â”‚       â”‚   â””â”€â”€ db.ts
    â”‚       â”œâ”€â”€ middlewares/
    â”‚       â”‚   â”œâ”€â”€ auth.middleware.ts
    â”‚       â”‚   â””â”€â”€ multer.middleware.ts
    â”‚       â”œâ”€â”€ models/
    â”‚       â”‚   â”œâ”€â”€ comment.model.ts
    â”‚       â”‚   â”œâ”€â”€ community.model.ts
    â”‚       â”‚   â”œâ”€â”€ post.model.ts
    â”‚       â”‚   â””â”€â”€ user.model.ts
    â”‚       â”œâ”€â”€ routes/
    â”‚       â”‚   â”œâ”€â”€ ai.routes.ts
    â”‚       â”‚   â”œâ”€â”€ comment.routes.ts
    â”‚       â”‚   â”œâ”€â”€ community.routes.ts
    â”‚       â”‚   â”œâ”€â”€ healthCheck.routes.ts
    â”‚       â”‚   â”œâ”€â”€ post.routes.ts
    â”‚       â”‚   â””â”€â”€ user.routes.ts
    â”‚       â”œâ”€â”€ schemas/
    â”‚       â”‚   â”œâ”€â”€ communitySchema.ts
    â”‚       â”‚   â””â”€â”€ postSchema.ts
    â”‚       â”œâ”€â”€ types/
    â”‚       â”‚   â””â”€â”€ userTypes.ts
    â”‚       â””â”€â”€ utils/
    â”‚           â”œâ”€â”€ apiError.ts
    â”‚           â”œâ”€â”€ apiResponse.ts
    â”‚           â”œâ”€â”€ asyncHandler.ts
    â”‚           â”œâ”€â”€ cloudinary.ts
    â”‚           â”œâ”€â”€ logger.ts
    â”‚           â””â”€â”€ ratelimit.ts
    â””â”€â”€ frontend/
        â”œâ”€â”€ README.md
        â”œâ”€â”€ components.json
        â”œâ”€â”€ next.config.mjs
        â”œâ”€â”€ package.json
        â”œâ”€â”€ postcss.config.mjs
        â”œâ”€â”€ tailwind.config.ts
        â”œâ”€â”€ tsconfig.json
        â”œâ”€â”€ .eslintrc.json
        â”œâ”€â”€ .npmrc
        â”œâ”€â”€ .prettierignore
        â”œâ”€â”€ .prettierrc
        â”œâ”€â”€ src/
        â”‚   â”œâ”€â”€ app/
        â”‚   â”‚   â”œâ”€â”€ formbricks.tsx
        â”‚   â”‚   â”œâ”€â”€ globals.css
        â”‚   â”‚   â”œâ”€â”€ layout.tsx
        â”‚   â”‚   â”œâ”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ providers.tsx
        â”‚   â”‚   â”œâ”€â”€ c/
        â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
        â”‚   â”‚   â”‚   â””â”€â”€ [community]/
        â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ communities/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ create-community/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ create-post/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ downvoted/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ languages/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ login/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ post/
        â”‚   â”‚   â”‚   â””â”€â”€ [postId]/
        â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ profile/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ register/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ saved/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ search/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ settings/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ u/
        â”‚   â”‚   â”‚   â””â”€â”€ [userName]/
        â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
        â”‚   â”‚   â”œâ”€â”€ update-post/
        â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
        â”‚   â”‚   â””â”€â”€ upvoted/
        â”‚   â”‚       â””â”€â”€ page.tsx
        â”‚   â”œâ”€â”€ components/
        â”‚   â”‚   â”œâ”€â”€ AiAnswerCard.tsx
        â”‚   â”‚   â”œâ”€â”€ AvatarDropdown.tsx
        â”‚   â”‚   â”œâ”€â”€ ChangePassword.tsx
        â”‚   â”‚   â”œâ”€â”€ CommentItem.tsx
        â”‚   â”‚   â”œâ”€â”€ Comments.tsx
        â”‚   â”‚   â”œâ”€â”€ CommunityItem.tsx
        â”‚   â”‚   â”œâ”€â”€ CommunityOptionsModal.tsx
        â”‚   â”‚   â”œâ”€â”€ CommunityPosts.tsx
        â”‚   â”‚   â”œâ”€â”€ Dashboard.tsx
        â”‚   â”‚   â”œâ”€â”€ DownvotedPosts.tsx
        â”‚   â”‚   â”œâ”€â”€ Hamburger.tsx
        â”‚   â”‚   â”œâ”€â”€ JoinedCommunities.tsx
        â”‚   â”‚   â”œâ”€â”€ LoginForm.tsx
        â”‚   â”‚   â”œâ”€â”€ MutationButton.tsx
        â”‚   â”‚   â”œâ”€â”€ NavBar.tsx
        â”‚   â”‚   â”œâ”€â”€ NotLoggedIn.tsx
        â”‚   â”‚   â”œâ”€â”€ PostItem.tsx
        â”‚   â”‚   â”œâ”€â”€ Posts.tsx
        â”‚   â”‚   â”œâ”€â”€ PostsByUsername.tsx
        â”‚   â”‚   â”œâ”€â”€ PostsNotFound.tsx
        â”‚   â”‚   â”œâ”€â”€ ProfileCard.tsx
        â”‚   â”‚   â”œâ”€â”€ RegisterForm.tsx
        â”‚   â”‚   â”œâ”€â”€ SavedPosts.tsx
        â”‚   â”‚   â”œâ”€â”€ SearchBar.tsx
        â”‚   â”‚   â”œâ”€â”€ SetDownloadPath.tsx
        â”‚   â”‚   â”œâ”€â”€ SideBar.tsx
        â”‚   â”‚   â”œâ”€â”€ theme-provider.tsx
        â”‚   â”‚   â”œâ”€â”€ UpdateUsername.tsx
        â”‚   â”‚   â”œâ”€â”€ UploadAvatar.tsx
        â”‚   â”‚   â”œâ”€â”€ UploadCoverImage.tsx
        â”‚   â”‚   â”œâ”€â”€ UpvotedPosts.tsx
        â”‚   â”‚   â”œâ”€â”€ UserPosts.tsx
        â”‚   â”‚   â”œâ”€â”€ animations/
        â”‚   â”‚   â”‚   â””â”€â”€ FullPagePreLoader.tsx
        â”‚   â”‚   â”œâ”€â”€ buttons/
        â”‚   â”‚   â”‚   â”œâ”€â”€ BackButton.tsx
        â”‚   â”‚   â”‚   â”œâ”€â”€ CopyCodeButton.tsx
        â”‚   â”‚   â”‚   â”œâ”€â”€ DeletePostButton.tsx
        â”‚   â”‚   â”‚   â”œâ”€â”€ ExplainThis.tsx
        â”‚   â”‚   â”‚   â”œâ”€â”€ UploadCodeFromFile.tsx
        â”‚   â”‚   â”‚   â”œâ”€â”€ UploadCodeFromGithub.tsx
        â”‚   â”‚   â”‚   â””â”€â”€ VSCodeButton.tsx
        â”‚   â”‚   â”œâ”€â”€ skeletons/
        â”‚   â”‚   â”‚   â”œâ”€â”€ CommentsSkeleton.tsx
        â”‚   â”‚   â”‚   â”œâ”€â”€ CommunitiesSkeleton.tsx
        â”‚   â”‚   â”‚   â”œâ”€â”€ PostSkeleton.tsx
        â”‚   â”‚   â”‚   â””â”€â”€ PostsLoading.tsx
        â”‚   â”‚   â””â”€â”€ ui/
        â”‚   â”‚       â”œâ”€â”€ badge.tsx
        â”‚   â”‚       â”œâ”€â”€ button.tsx
        â”‚   â”‚       â”œâ”€â”€ card.tsx
        â”‚   â”‚       â”œâ”€â”€ drawer.tsx
        â”‚   â”‚       â”œâ”€â”€ input.tsx
        â”‚   â”‚       â”œâ”€â”€ label.tsx
        â”‚   â”‚       â”œâ”€â”€ scroll-area.tsx
        â”‚   â”‚       â”œâ”€â”€ select.tsx
        â”‚   â”‚       â”œâ”€â”€ sheet.tsx
        â”‚   â”‚       â”œâ”€â”€ skeleton.tsx
        â”‚   â”‚       â”œâ”€â”€ textarea.tsx
        â”‚   â”‚       â”œâ”€â”€ toast.tsx
        â”‚   â”‚       â”œâ”€â”€ toaster.tsx
        â”‚   â”‚       â””â”€â”€ use-toast.ts
        â”‚   â”œâ”€â”€ hooks/
        â”‚   â”‚   â””â”€â”€ useTitle.tsx
        â”‚   â”œâ”€â”€ lib/
        â”‚   â”‚   â””â”€â”€ utils.ts
        â”‚   â”œâ”€â”€ store/
        â”‚   â”‚   â””â”€â”€ userStore.ts
        â”‚   â”œâ”€â”€ types/
        â”‚   â”‚   â”œâ”€â”€ commentTypes.ts
        â”‚   â”‚   â”œâ”€â”€ postTypes.ts
        â”‚   â”‚   â””â”€â”€ userTypes.ts
        â”‚   â””â”€â”€ utils/
        â”‚       â”œâ”€â”€ axios.ts
        â”‚       â”œâ”€â”€ classnames.tsx
        â”‚       â”œâ”€â”€ constants.ts
        â”‚       â””â”€â”€ get-query-client.ts
        â””â”€â”€ .husky/
            â””â”€â”€ pre-commit

================================================
FILE: README.md
================================================
<a href="https://codestash.baghel.dev" target="_blank">![2024-10-08_19-39](https://github.com/user-attachments/assets/1d4cc0f8-091f-4308-8305-2f031a4214fe)</a>

# CodeStash ğŸ“ğŸ’»

[Deployed Site](https://codestash.baghel.dev)

Codestash is a full-stack web app where developers can share, store, and discover code snippets. With community-driven features and AI-powered enhancements, Codestash blends the social dynamics of Reddit with the technical expertise of Stack Overflow.

### Features:
- ğŸ”’ **User Authentication & Profiles**: Sign up, log in, and manage your personal code stash.
- âœï¸ **Create, Read, Update, Delete (CRUD)**: Easily create and manage your code snippets.
- ğŸŒ **Community-Based Organization**: Share snippets with the community, organized by tags and topics.
- ğŸ’» **Multi-Language Support**: Store snippets in various programming languages.
- ğŸ¨ **Code Syntax Highlighting**: Enhanced readability with syntax highlighting.
- ğŸ‘ **Upvoting/Downvoting System**: Vote on the most useful snippets.
- ğŸ¤– **AI-Powered Code Explanations**: Get AI-generated explanations for code snippets.
- ğŸ”— **VS Code Integration**: Open code snippets in VS Code.

Codestash creates a collaborative space for developers, making it easy to find, share, and improve code with a supportive community.

## Screenshots
![2024-09-24_21-26](https://github.com/user-attachments/assets/e85e4fe2-ed6a-4ebe-a4f5-856e8d161964)
![2024-09-24_21-29](https://github.com/user-attachments/assets/13480a55-d585-4dba-8bea-3175ef952eca)
![2024-09-24_21-30](https://github.com/user-attachments/assets/6feca847-cd7e-4ed0-848d-54f8cb794d86)
![2024-10-08_19-54_1](https://github.com/user-attachments/assets/19359b97-6344-4683-b8cd-78c6b1305db3)
![2024-10-08_19-53](https://github.com/user-attachments/assets/a2edcbb7-bf81-4688-ae95-687edf1576f1)
![2024-09-24_21-27](https://github.com/user-attachments/assets/a604b4fc-b248-4e23-b99b-5d544fff26ad)
![2024-10-08_19-54](https://github.com/user-attachments/assets/350a3ce6-e64f-45ab-b1dc-530258ff2e0a)
![2024-09-24_21-28](https://github.com/user-attachments/assets/f5230bde-c8f3-4fd2-8dea-450d03227fc5)
![2024-09-24_21-28_1](https://github.com/user-attachments/assets/a4e3b648-b8da-444d-a2f0-e7ad1d8e6557)



## Tech Stack

### Frontend:
- **Framework**: [Next.js](https://nextjs.org) (v14.2.1)
- **Styling**: [TailwindCSS](https://tailwindcss.com) (v3.4.10), [Tailwind CSS Animate](https://github.com/joe-bell/tailwindcss-animate) (v1.0.7)
- **State Management**: [Zustand](https://zustand-demo.pmnd.rs) (v4.5.5)
- **Data Fetching**: [React Query](https://tanstack.com/query/v5) (v5.52.1)
- **Animations**: [Framer Motion](https://www.framer.com/motion/) (v11.5.4), [Auto Animate](https://formkit.com/auto-animate) (v0.8.2)
- **UI Components**: [Radix UI](https://www.radix-ui.com) (Dialog, Select, Toast, etc.), [NextUI](https://nextui.org) (v2.4.6)
- **Markdown Rendering**: [React Markdown Preview](https://uiwjs.github.io/react-markdown-preview/) (v5.1.3), [Markdown-to-JSX](https://github.com/probablyup/markdown-to-jsx) (v7.5.0)
- **Utilities**: [Axios](https://axios-http.com) (v1.7.5), [clsx](https://github.com/lukeed/clsx) (v2.1.1)
- **Code Editor**: [React Textarea Code Editor](https://uiwjs.github.io/react-textarea-code-editor/) (v3.0.2)

### Backend:
- **Framework**: [Express.js](https://expressjs.com) (v4.19.2)
- **Database**: [MongoDB](https://www.mongodb.com) with [Mongoose](https://mongoosejs.com) (v8.5.4)
- **Authentication**: [JWT](https://jwt.io) (v9.0.2), [bcrypt](https://www.npmjs.com/package/bcrypt) (v5.1.1)
- **File Uploads**: [Multer](https://github.com/expressjs/multer) (v1.4.5-lts.1), [Cloudinary](https://cloudinary.com) (v2.4.0)
- **Security**: [Helmet](https://helmetjs.github.io) (v7.1.0), [CORS](https://www.npmjs.com/package/cors) (v2.8.5), [Cookie Parser](https://www.npmjs.com/package/cookie-parser) (v1.4.6)
- **Logging**: [Pino](https://getpino.io) (v9.3.2)
- **Validation**: [Zod](https://zod.dev) (v3.23.8)
- **AI-powered Code Explanations**: [Google Generative AI](https://developers.generativeai.google) (v0.19.0)
- **Rate Limiting**: [Unkey](https://www.unkey.com/)

### Development Tools:
- **Frontend**: TypeScript, ESLint, Prettier, Husky
- **Backend**: TypeScript, Vitest, Tsup, ESLint, Prettier
- **Build & Dev**: [Tsup](https://github.com/egoist/tsup) (v8.2.4), [TSX](https://github.com/esbuild-kit/tsx) (v4.17.0), [Rimraf](https://github.com/isaacs/rimraf) (v5.0.10)

## License

This project is licensed under the **GNU General Public License v3.0**.  
You may copy, distribute, and modify the software as long as you track changes/dates in source files.  
Any modifications to the codebase must also be made available under the same license.

See the [LICENSE](https://github.com/Devansh-Baghel/CodeStash/blob/main/LICENSE) file for more details.



================================================
FILE: LICENSE
================================================
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) 2024  Devansh Baghel
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.



================================================
FILE: todo.md
================================================
## Done

- [x] login page
- [x] register page
- [x] restructure project
- [x] write backend boilerplate
- [x] convert js boilerplate to ts
- [x] Loading components in /post/[postId]
- [x] Loading components in /post/[postId] Comments
- [x] Loading components in /
- [x] Loading components in /saved
- [x] Loading components in /upvotes
- [x] Loading components in /downvotes
- [x] redirect user to / when loggedin
- [x] /profile ui for not-logged-in user
- [x] save post feature for logged-in user
- [x] find a good favicon
- [x] change upvote downvote icons when clicked, also will have to save the upvotes and downvotes in user's model
- [x] add useTitle hook to every page
- [x] add download file option in post/[postID]
- [x] delete post toast
- [x] replace all h-5 w-5, h-4 w-4 with size-5, size-4 etc
- [x] search posts controller
- [x] search posts ui
- [x] create post from github link
- [x] create post from github raw link
- [x] create post from github gist link
- [x] create post from github gist raw link
- [x] create post from local file
- [x] filetype validations in create post from local file
- [x] add toast to tell user to set the download path before they try to open in vscode
- [x] add a limit on the number of characters that a user can enter into a post in /create-post
- [x] add a limit on the number of characters that a user can enter into a post in /update-post
- [x] add upload from github and upload local file features in /update-post
- [x] redirect user to /post/postid after updating a post
- [x] ai controllers
- [x] ai routes
- [x] ai works in backend
- [x] ai works in frontend
- [x] explain this snippet ai feature
- [x] show parsed markdown in the ai answer on frontend
- [x] tell gemini to give small and concise answers
- [x] fix: theme inside create-post and update-post code editors has changed to light mode because of markdown parsing being done by the same library
- [x] must be logged in user to use the ai features
- [x] remove unneccacary packages from frontend
- [x] better code display component in /post/postId from @uiwjs
- [x] show/hide option for profile card
- [x] add avatar dropdown menu from nextui
- [x] auto animate when hiding/showing profile card
- [x] fix: toasts animating weirdly because of auto animate
- [x] paginate in backend
- [x] paginate in frontend
- [x] paginate posts-by-lang endpoint
- [x] paginate / that currently sends all the posts
- [x] add explain this button in in AiAnswerCard when user hasn't gotten ai answer yet.
- [x] add mutation button component
- [x] better client side navigation without router.push()
- [x] use Links instead of router.push, because router.push does not prefetch any page
- [x] fix nextui ui Links doing a full page reload
- [x] add custom info toasts
- [x] change shadcn alert to nextui modal, animations aren't working in shadcn in DeletePostButton and CommentItem
- [x] remove unneccacary packages from backend
- [x] remove demo user download path
- [x] add react-query proper way, so queries don't refetch every time
- [x] proper login page errors
- [x] proper register page errors
- [x] shorten long post descriptions on PostItem view
- [x] shorten long community descriptions on CommunityItem view
- [x] invalidate your posts /profile when create post, delete post, update post
- [x] tell user to not enter spaces in communities name, parse community name to be url friendly
- [x] add full page preloader
- [x] add login as a demo user for mobile screens
- [x] add api ratelimiting to the /ai/explain endpoint

## Not Done

- [ ] add formatting for number of comments, posts, upvotes, downvotes, etc like 1k, 2k, 3k, 1M, 2M, 3M etc
- [ ] create list feature for users to create a list of snippets etc.
- [ ] add loading user data loader in generic component to fetch the current user and block all rendering until then
- [ ] verify user before deleting community
- [ ] add "design help: nikhil" in final project readme
- [ ] add better errors in all page
- [ ] add "remove from upvotes" in /upvotes similar to "remove from saved" in /saved
- [ ] add "remove from downvotes" in /downvotes similar to "remove from saved" in /saved
- [ ] faq page maybe?
- [ ] add more allowed languages
- [ ] organise all components into folders
- [ ] only make get current user if the localstorage has userData or loggedIn
- [ ] allow user to import all snippets from github gist
- [ ] upload snippet as github gist
- [ ] search button for not logged in user in sidebar (sidebar for not logged in user is empty)
- [ ] draft posts feature
- [ ] forgot password feature
- [ ] remove all ts ignore and fix all userTypes errors with !
- [ ] add error toast if github link is a private repo, and returns 404
- [ ] add react window to unload all components that aren't visible
- [ ] test open in vs code feature in windows
- [ ] test open in vs code feature without vs code install
- [ ] add id in all toasts so that they don't repeat on multiple clicks
- [ ] create a preview/banner image for codestash to add in github
- [ ] save ai answer in post model for future requests, if post model doesn't have ai answer then generate the ai answer (this is to save tokens + reduce ai requests)
- [ ] move copy to code and save post button at the top of the code content
- [ ] check text encoding 004 model if users hit 15rpm or token limit.
- [ ] Suspense or loading.tsx components for instant feedback when user clicks to go on a route
- [ ] better font for the title "CodeStash"
- [ ] add made with love by devansh baghel at the end of every section
- [ ] add page heading when components loading screens are present
- [ ] paginate posts-by-username endpoint
- [ ] add code embed feature
- [ ] add code share feature, share code on various platforms
- [ ] add feature to convert code snippet into a github gist post.
- [ ] in search page add tabs for "All matches", "Title", "Code", "Description"
- [ ] responsive
  1. [x] /
  2. [x] /profile
  3. [x] /saved
  4. [x] /upvoted
  5. [x] /downvoted
  6. [x] /u/username
  7. [x] /c/community
  8. [x] /languages
  9. [x] /settings
  10. [x] /login
  11. [x] /register
  12. [x] /communities
  13. [ ] /create-post
  14. [x] /create-community
  15. [ ] /update-post
  16. [x] /post/postid
- [ ] add option to create-post in hamburger menu
- [ ] add option to create-community in hamburger menu
- [ ] add option to popular-languages in hamburger menu
- [ ] add option to account-settings in hamburger menu
- [ ] search another user option
- [ ] message another user option
- [ ] follow user option
- [ ] Loading screen in /u/username
- [ ] add og/meta tags for SEO
- [ ] replace all mutations with mutation button component
- [ ] add CodeRabbit in github
- [ ] use nextui block links instead of the button as a link https://nextui.org/docs/components/link#block-link
- [ ] use router.prefetch to prefetch the links that can't be converted to next/link
- [ ] display language tags with skillicons.dev
- [ ] create a custom useEffect wrapper hook that prefetches a page
- [ ] update post doesn't work, react query caching issue / nextjs caching issue.
- [ ] add auto crop option for avatars and cover images, https://www.npmjs.com/package/smartcrop
- [ ] reloading /c/community doesn't show admin options
- [ ] proper username parsing, cant contain spaces etc
- [ ] ask user password again when someone tries to change it




================================================
FILE: backend/eslint.config.mjs
================================================
import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";

export default [
  { languageOptions: { globals: globals.browser } },
  pluginJs.configs.recommended,
  ...tseslint.configs.recommended,
];



================================================
FILE: backend/package.json
================================================
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "tsx watch --clear-screen=false -r dotenv/config src/index | pino-pretty",
    "build": "tsup --clean",
    "start": "node -r dotenv/config dist/index.js",
    "format:check": "prettier --check .",
    "format:write": "prettier --write .",
    "lint:check": "eslint .",
    "lint:fix": "eslint --fix ."
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@google/generative-ai": "^0.19.0",
    "@unkey/ratelimit": "^0.4.7",
    "bcryptjs": "^3.0.2",
    "cloudinary": "^2.7.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.6.0",
    "express": "^4.21.2",
    "helmet": "^7.2.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.16.1",
    "multer": "1.4.5-lts.1",
    "pino": "^9.7.0",
    "pino-http": "^10.5.0",
    "tsup": "^8.5.0",
    "unique-username-generator": "^1.4.0",
    "zod": "^3.25.67"
  },
  "devDependencies": {
    "@eslint/js": "^9.29.0",
    "@types/bcrypt": "^5.0.2",
    "@types/cookie-parser": "^1.4.9",
    "@types/cors": "^2.8.19",
    "@types/express": "^4.17.23",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/multer": "^1.4.13",
    "@types/node": "^20.19.1",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "globals": "^15.15.0",
    "pino-pretty": "^11.3.0",
    "prettier": "^3.6.2",
    "tsx": "^4.20.3",
    "typescript": "^5.8.3",
    "typescript-eslint": "^7.18.0",
    "vitest": "^3.2.4"
  }
}



================================================
FILE: backend/tsconfig.json
================================================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "es2016" /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */,
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs" /* Specify what module code is generated. */,
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */,
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true /* Ensure that casing is correct in imports. */,

    /* Type Checking */
    "strict": true /* Enable all strict type-checking options. */,
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  }
}



================================================
FILE: backend/tsup.config.ts
================================================
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["./src"],
  splitting: false,
  sourcemap: true,
  clean: true,
});



================================================
FILE: backend/.prettierignore
================================================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts



================================================
FILE: backend/public/temp/.gitkeep
================================================



================================================
FILE: backend/src/app.ts
================================================
import cookieParser from "cookie-parser";
import cors from "cors";
import express from "express";
import helmet from "helmet";
import pinoHttp from "pino-http";

const app = express();

app.use(
  cors({
    origin: [process.env.CORS_ORIGIN!],
    credentials: true,
  })
);

app.use(express.json({ limit: "16kb" }));
app.use(express.urlencoded({ extended: true, limit: "16kb" }));
app.use(express.static("public"));
app.use(cookieParser());
app.use(helmet());
app.use(pinoHttp());

// Routes
import commentRouter from "./routes/comment.routes";
import communityRouter from "./routes/community.routes";
import healthCheckRouter from "./routes/healthCheck.routes";
import postRouter from "./routes/post.routes";
import userRouter from "./routes/user.routes";
import aiRouter from "./routes/ai.routes";

app.use("/api", healthCheckRouter);
app.use("/api/users", userRouter);
app.use("/api/posts", postRouter);
app.use("/api/comments", commentRouter);
app.use("/api/community", communityRouter);
app.use("/api/ai", aiRouter);

export default app;



================================================
FILE: backend/src/constants.ts
================================================
import { CookieOptions } from "express";

export const DB_NAME = "CodeStash";
export const PORT = process.env.PORT || 8000;
export const cookieOptions: CookieOptions = {
  httpOnly: true,
  secure: true,
  sameSite: "none",
};



================================================
FILE: backend/src/index.ts
================================================
import dotenv from "dotenv";

import app from "./app";
import { PORT } from "./constants";
import connectDB from "./db/db";
import logger from "./utils/logger";

dotenv.config({
  path: "../.env",
});

connectDB()
  .then(() => {
    app.listen(PORT, () => {
      logger.info(`Server Running on Port: ${PORT}`);
    });
  })
  .catch((err) => {
    logger.error("MongoDB Connection failed !!!");
    throw err;
  });



================================================
FILE: backend/src/controllers/ai.controller.ts
================================================
import { Post } from "../models/post.model";
import { UserRequest } from "../types/userTypes";
import { ApiError } from "../utils/apiError";
import { ApiResponse } from "../utils/apiResponse";
import { asyncHandler } from "../utils/asyncHandler";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { limiter } from "../utils/ratelimit";

const githubAlerts = `
> 
> [!NOTE]
> Useful information that users should know, even when skimming content.

> [!TIP]
> Helpful advice for doing things better or more easily.

> [!IMPORTANT]
> Key information users need to know to achieve their goal.

> [!WARNING]
> Urgent info that needs immediate user attention to avoid problems.

> [!CAUTION]
> Advises about risks or negative outcomes of certain actions.
`;

export const getAiAnswer = asyncHandler(async (req: UserRequest, res) => {
  const { postId } = req.query;
  const identifier = req.ip!;

  const ratelimit = await limiter.limit(identifier);
  if (!ratelimit.success) throw new ApiError(429, "Too many requests");

  if (!postId) return new ApiError(400, "Post id is required to get comments");

  const post = await Post.findById(postId);

  if (!post) throw new ApiError(404, "Post with this id does not exist");

  const apiKey = process.env.GEMINI_API_KEY!;
  const genAI = new GoogleGenerativeAI(apiKey);

  const model = genAI.getGenerativeModel({
    model: "gemini-1.5-flash",
  });

  const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 64,
    maxOutputTokens: 8192,
    responseMimeType: "text/plain",
  };

  const chatSession = model.startChat({
    generationConfig,
    // safetySettings: Adjust safety settings
    // See https://ai.google.dev/gemini-api/docs/safety-settings
    history: [],
  });

  const prompt = `I am providing you a code snippet, please explain me this code snippet, only give small and consice explanation, only give answers in valid markdown format, make sure to use markdown format extensively, if possible use indenting in the markdown in bullet points etc. Make sure to include EXACTLY ONE (choose between NOTE, TIP, IMPORTANT, WARNING, CAUTION depending on your explanation of the code, only use CAUTION and WARNING when there is a severe problem in the code) of the following github alerts at the top of your response, in this exact format including > symbol: ${githubAlerts}. The code snippet is: ${post.content}`;

  const result = await chatSession.sendMessage(prompt);
  const aiAnswer = result.response.text();

  return res
    .status(200)
    .json(new ApiResponse(200, { aiAnswer }, "AI answer sent successfully"));
});



================================================
FILE: backend/src/controllers/comment.controllers.ts
================================================
import { Comment } from "../models/comment.model";
import { Post } from "../models/post.model";
import { UserRequest } from "../types/userTypes";
import { ApiError } from "../utils/apiError";
import { ApiResponse } from "../utils/apiResponse";
import { asyncHandler } from "../utils/asyncHandler";

export const getComments = asyncHandler(async (req, res) => {
  const { postId } = req.body;

  if (!postId) {
    return new ApiError(400, "Post id is required to get comments");
  }

  const post = await Post.findById(postId);

  if (!post) return new ApiError(404, "Post with this id does not exist");

  let comments = await Comment.find({ _id: { $in: post.comments } });

  comments = comments.reverse();

  return res
    .status(200)
    .json(new ApiResponse(200, comments, "Comments sent successfully"));
});

export const createComment = asyncHandler(async (req: UserRequest, res) => {
  const { content, postId } = req.body;
  const user = req.user;

  if (!content) throw new ApiError(400, "Comment body is required");

  const post = await Post.findById(postId);

  if (!post) throw new ApiError(404, "Post with this postId not found");

  const comment = await Comment.create({
    madeBy: { userId: user?._id, username: user?.username },
    parent: post._id,
    type: "comment",
    content,
  });

  post.comments?.push(comment._id);

  // FIXME: fix ts errors
  if (!post.madeBy.username) {
    // @ts-ignore
    post.madeBy.username = user?.username;
  }

  await post.save();

  return res
    .status(200)
    .json(new ApiResponse(200, comment, "Comment created successfully"));
});

export const upvoteComment = asyncHandler(async (req: UserRequest, res) => {
  const { commentId } = req.body;
  const user = req.user;

  if (!commentId) {
    throw new ApiError(400, "Comment id is required to upvote the comment");
  }

  // Remove the upvote
  if (user?.upvotedComments.includes(commentId)) {
    const updatedComment = await Comment.findByIdAndUpdate(commentId, {
      $inc: { upvotes: -1 },
    });

    user.upvotedComments = user.upvotedComments.filter(
      (item) => item.toString() !== commentId,
    );

    await user.save();

    return res
      .status(200)
      .json(
        new ApiResponse(
          200,
          { updatedComment, user },
          "Comment was already upvoted, so removed it from upvotedComments",
        ),
      );
  }

  let updatedComment;

  // If user has downvoted the post before, we remove that here
  if (user?.downvotedComments.includes(commentId)) {
    updatedComment = await Comment.findByIdAndUpdate(commentId, {
      $inc: { upvotes: +1, downvotes: -1 },
    });
    user.downvotedComments = user.downvotedComments.filter(
      (item) => item.toString() !== commentId,
    );
  } else {
    updatedComment = await Comment.findByIdAndUpdate(commentId, {
      $inc: { upvotes: +1 },
    });
  }

  if (!updatedComment) {
    throw new ApiError(404, "Comment with this id does not exist");
  }

  user?.upvotedComments.push(commentId);
  await user?.save();

  return res
    .status(200)
    .json(
      new ApiResponse(
        200,
        { updatedComment, user },
        "Post upvoted successfully",
      ),
    );
});

export const downvoteComment = asyncHandler(async (req: UserRequest, res) => {
  const { commentId } = req.body;
  const user = req.user;

  if (!commentId) {
    throw new ApiError(400, "Comment id is required to downvote the comment");
  }

  // Remove the downvote
  if (user?.downvotedComments.includes(commentId)) {
    const updatedComment = await Comment.findByIdAndUpdate(commentId, {
      $inc: { downvotes: -1 },
    });

    user.downvotedComments = user.downvotedComments.filter(
      (item) => item.toString() !== commentId,
    );

    await user.save();

    return res
      .status(200)
      .json(
        new ApiResponse(
          200,
          { updatedComment, user },
          "Comment was downvoted already, so removing the downvote instead",
        ),
      );
  }

  let updatedComment;

  // If user has upvoted the comment before, we remove that here
  if (user?.upvotedComments.includes(commentId)) {
    updatedComment = await Comment.findByIdAndUpdate(commentId, {
      $inc: { downvotes: +1, upvotes: -1 },
    });

    user.upvotedComments = user.upvotedComments.filter(
      (item) => item.toString() !== commentId,
    );
  } else {
    updatedComment = await Comment.findByIdAndUpdate(commentId, {
      $inc: { downvotes: +1 },
    });
  }

  if (!updatedComment) {
    throw new ApiError(404, "Comment with this id does not exist");
  }

  user?.downvotedComments.push(commentId);
  await user?.save();

  return res
    .status(200)
    .json(
      new ApiResponse(
        200,
        { updatedComment, user },
        "Post downvoted successfully",
      ),
    );
});

// TODO: fix all "return new ApiError" with "throw new ApiError"

export const updateComment = asyncHandler(async (req: UserRequest, res) => {
  const { commentId, content } = req.body;
  const user = req.user;

  if (!commentId)
    throw new ApiError(400, "Comment id is required to update comment");
  if (!content)
    throw new ApiError(400, "Comment body is required to update comment");

  const comment = await Comment.findById(commentId);

  if (!comment) throw new ApiError(404, "Comment with this id does not exist");

  if (comment.madeBy.username !== user?.username)
    throw new ApiError(403, "You are not authorized to update this comment");

  comment.content = content;
  comment.isEdited = true;
  await comment.save();

  return res
    .status(200)
    .json(new ApiResponse(200, comment, "Comment updated successfully"));
});

export const deleteComment = asyncHandler(async (req: UserRequest, res) => {
  const { commentId } = req.body;
  const user = req.user;

  if (!commentId)
    throw new ApiError(400, "Comment id is required to delete comment");

  const comment = await Comment.findById(commentId);

  if (!comment) throw new ApiError(404, "Comment with this id does not exist");

  if (comment.madeBy.username !== user?.username)
    throw new ApiError(403, "You are not authorized to delete this comment");

  await comment.deleteOne();

  return res
    .status(200)
    .json(new ApiResponse(200, {}, "Comment deleted successfully"));
});



================================================
FILE: backend/src/controllers/community.controllers.ts
================================================
import { z } from "zod";
import { Community } from "../models/community.model";
import { communityNameSchema } from "../schemas/communitySchema";
import { UserRequest } from "../types/userTypes";
import { ApiError } from "../utils/apiError";
import { ApiResponse } from "../utils/apiResponse";
import { asyncHandler } from "../utils/asyncHandler";
import { uploadOnCloudinary } from "../utils/cloudinary";

// TODO: Add extra validation for name of cummunity, it cant contain whitespace for example
export const createCommunity = asyncHandler(async (req: UserRequest, res) => {
  let { name, description } = req.body;
  const user = req.user;

  if (!name) throw new ApiError(400, "Name of community is required");
  if (!description)
    throw new ApiError(400, "Description of community is required");

  name = name.trim();
  name = name.replaceAll(" ", "-");

  try {
    name = communityNameSchema.parse(name);
  } catch (error) {
    throw new ApiError(
      400,
      (error as z.ZodError).errors[0]?.message || "Invalid subreddit name"
    );
  }

  const doesCommunityExist = await Community.findOne({ name });
  if (doesCommunityExist)
    throw new ApiError(409, "A community with this name already exists");

  const community = await Community.create({
    name,
    description,
    madeBy: {
      userId: user?._id,
      username: user?.username,
    },
  });

  if (!community) {
    throw new ApiError(
      500,
      "Something went wrong while creating the community"
    );
  }

  user?.communitiesJoined.push(community.name);

  await user?.save();

  return res
    .status(201)
    .json(
      new ApiResponse(
        201,
        { user, community },
        "Community created successfully"
      )
    );
});

export const getCommunities = asyncHandler(async (req, res) => {
  const communities = await Community.find({});

  return res
    .status(200)
    .json(new ApiResponse(200, communities, "Communities sent successfully"));
});

export const getCommunity = asyncHandler(async (req, res) => {
  const { name } = req.body;
  if (!name)
    throw new ApiError(400, "Community name is required to get it's details");

  const community = await Community.findOne({ name });
  if (!community)
    throw new ApiError(404, "Community with this name does not exist");

  return res
    .status(200)
    .json(
      new ApiResponse(200, community, "Community details sent successfully")
    );
});

export const joinCommunity = asyncHandler(async (req: UserRequest, res) => {
  const { community } = req.body;
  const user = req.user;

  if (!community)
    throw new ApiError(400, "Community name is required to join a community");

  if (user?.communitiesJoined.includes(community)) {
    throw new ApiError(400, "You have already joined this community");
  }

  const updatedCommunity = await Community.findOneAndUpdate(
    { name: community },
    { $inc: { joinedMembers: +1 } }
  );

  if (!updatedCommunity)
    throw new ApiError(404, "Community with this name does not exist");

  user?.communitiesJoined.push(community);
  await user?.save();

  return res
    .status(200)
    .json(
      new ApiResponse(
        200,
        { updatedCommunity, user },
        "Community joined successfully"
      )
    );
});

export const leaveCommunity = asyncHandler(async (req: UserRequest, res) => {
  const { community } = req.body;
  const user = req.user;

  if (!community) throw new ApiError(400, "Community name is required");

  if (!user?.communitiesJoined.includes(community)) {
    throw new ApiError(
      400,
      "You haven't joined this community yet, can't remove"
    );
  }

  const updatedCommunity = await Community.findOneAndUpdate(
    { name: community },
    { $inc: { joinedMembers: -1 } }
  );

  user.communitiesJoined = user.communitiesJoined.filter(
    (item) => item !== community
  );

  await user?.save();

  return res
    .status(200)
    .json(
      new ApiResponse(
        200,
        { updatedCommunity, user },
        "Left the community successfully"
      )
    );
});

export const uploadAvatar = asyncHandler(async (req: UserRequest, res) => {
  const { name } = req.body;
  const avatarLocalPath = req?.file?.path;
  const user = req.user;

  if (!name) throw new ApiError(400, "Name of community is required");

  if (!avatarLocalPath) throw new ApiError(400, "Avatar file is required");

  const avatar = await uploadOnCloudinary(avatarLocalPath);

  if (!avatar) throw new ApiError(400, "Avatar file is required");

  const community = await Community.findOne({ name });
  if (!community) throw new ApiError(404, "Community not found");

  if (community.madeBy.username !== user?.username) {
    throw new ApiError(
      401,
      "You are not authorized to change the avatar image of this community"
    );
  }

  const updatedCommunity = await Community.findByIdAndUpdate(
    community._id,
    { avatar: avatar.url },
    { new: true }
  );

  if (!updatedCommunity)
    throw new ApiError(500, "Something went wrong uploading avatar");

  return res
    .status(200)
    .json(
      new ApiResponse(
        200,
        { community: updatedCommunity },
        "Avatar uploaded sucessfully"
      )
    );
});

export const uploadCoverImage = asyncHandler(async (req: UserRequest, res) => {
  const { name } = req.body;
  const coverImageLocalPath = req?.file?.path;
  const user = req.user;

  if (!name) throw new ApiError(400, "Name of community is required");

  if (!coverImageLocalPath)
    throw new ApiError(400, "Cover image file is required");

  const coverImage = await uploadOnCloudinary(coverImageLocalPath);

  if (!coverImage) throw new ApiError(400, "Cover image file is required");

  const community = await Community.findOne({ name });
  if (!community) throw new ApiError(404, "Community not found");

  if (community.madeBy.username !== user?.username) {
    throw new ApiError(
      401,
      "You are not authorized to change the cover image of this community"
    );
  }

  const updatedCommunity = await Community.findByIdAndUpdate(
    community._id,
    { coverImage: coverImage.url },
    { new: true }
  );

  if (!updatedCommunity)
    throw new ApiError(500, "Something went wrong uploading cover image");

  return res
    .status(200)
    .json(
      new ApiResponse(
        200,
        { community: updatedCommunity },
        "Cover image uploaded sucessfully"
      )
    );
});

export const updateCommunityInfo = asyncHandler(
  async (req: UserRequest, res) => {
    const { description, communityName } = req.body;
    const user = req.user;

    if (!description)
      throw new ApiError(400, "Description is required to update info.");

    const community = await Community.findOne({ name: communityName });

    if (!community) throw new ApiError(404, "Community does not exist");

    if (user?.username !== community.madeBy.username)
      throw new ApiError(401, "You are not allowed to update this community");

    community.description = description;

    await community.save();

    return res
      .status(200)
      .json(
        new ApiResponse(200, { community }, "Community updated successfully")
      );
  }
);



================================================
FILE: backend/src/controllers/healthCheck.controller.ts
================================================
import { asyncHandler } from "../utils/asyncHandler";

export const healthCheck = asyncHandler((req, res) => {
  res.send("Api is Healthy!");
});



================================================
FILE: backend/src/controllers/post.controllers.ts
================================================
import { Request, Response } from "express";
import { allowedLanguages, Post } from "../models/post.model";
import { postSchema } from "../schemas/postSchema";
import { UserRequest } from "../types/userTypes";
import { ApiError } from "../utils/apiError";
import { ApiResponse } from "../utils/apiResponse";
import { asyncHandler } from "../utils/asyncHandler";
import { User } from "../models/user.model";
import { Community } from "../models/community.model";

export const getPosts = asyncHandler(async (req: Request, res: Response) => {
  const page = parseInt(req.query.page as string) || 1; // Default to page 1 if not provided
  const limit = 10; // Send 10 posts at a time
  const skip = (page - 1) * limit;

  const posts = await Post.find()
    .sort({ createdAt: -1 })
    .skip(skip)
    .limit(limit);

  if (!posts || posts.length === 0)
    throw new ApiError(404, "There aren't any posts");

  const totalPosts = await Post.countDocuments();
  const totalPages = Math.ceil(totalPosts / limit);

  return res
    .status(200)
    .json(
      new ApiResponse(
        200,
        { posts, currentPage: page, totalPages, totalPosts },
        "Posts sent successfully"
      )
    );
});

export const getPost = asyncHandler(async (req, res) => {
  const { postId } = req.body;
  if (!postId) throw new ApiError(400, "Post id is required");

  const post = await Post.findById(postId);

  if (!post) throw new ApiError(404, "Post not found");

  return res
    .status(200)
    .json(new ApiResponse(200, post, "Post sent successfully"));
});

export const getPostsByLang = asyncHandler(
  async (req: UserRequest, res: Response) => {
    const { language } = req.body;
    const page = parseInt(req.query.page as string) || 1; // Default to page 1 if not provided
    const limit = 10; // Send 10 posts at a time
    const skip = (page - 1) * limit;

    if (!language) throw new ApiError(400, "Language is required");

    if (!allowedLanguages.includes(language)) {
      throw new ApiError(404, "This language isn't supported yet");
    }

    const posts = await Post.find({ language })
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    const totalPosts = await Post.countDocuments({ language });
    const totalPages = Math.ceil(totalPosts / limit);

    return res.status(200).json(
      new ApiResponse(
        200,
        {
          posts,
          currentPage: page,
          totalPages,
          totalPosts,
        },
        "Posts got successfully"
      )
    );
  }
);

export const getPostsByUsername = asyncHandler(
  async (req: UserRequest, res: Response) => {
    const { username } = req.body;
    if (!username) throw new ApiError(400, "Username is required");

    const findUser = await User.findOne({ username });
    if (!findUser) throw new ApiError(404, "User not found");

    const posts = await Post.find({ "madeBy.username": username });

    return res
      .status(200)
      .json(new ApiResponse(200, posts, "Posts sent successfully"));
  }
);

export const getPostsByCommunity = asyncHandler(async (req, res) => {
  const { community, filter } = req.body;
  if (!community)
    throw new ApiError(400, "Name of community is required to get posts");

  const findCommunity = await Community.findOne({ name: community });
  if (!findCommunity)
    throw new ApiError(404, "Community with this name does not exist");

  let posts;

  switch (filter) {
    case "Oldest":
      posts = await Post.find({ community }).sort({ createdAt: "asc" });
      break;
    case "Latest":
      posts = await Post.find({ community }).sort({ createdAt: "desc" });
      break;
    case "Popular":
      posts = await Post.find({ community }).sort({ comments: "desc" });
      break;
    default:
      throw new ApiError(400, "Filter option must be included");
  }

  return res
    .status(200)
    .json(new ApiResponse(200, posts, "Posts sent successfully"));
});

export const createPost = asyncHandler(
  async (req: UserRequest, res: Response) => {
    const { title, content, language, description, community } =
      postSchema.parse(req.body);

    const post = await Post.create({
      title,
      madeBy: {
        userId: req.user?._id,
        fullname: `${req.user?.firstName} ${req.user?.lastName}`,
        username: req.user?.username,
      },
      content,
      language,
      description,
      community: community ? community : "all",
    });

    return res
      .status(200)
      .json(
        new ApiResponse(
          200,
          post,
          `Post created successfully in c/${community}`
        )
      );
  }
);

export const upvotePost = asyncHandler(async (req: UserRequest, res) => {
  const { postId } = req.body;
  const user = req.user;

  if (!postId) {
    throw new ApiError(400, "Post id is required to upvote the post");
  }

  // Remove the upvote
  if (user?.upvotedPosts.includes(postId)) {
    const updatedPost = await Post.findByIdAndUpdate(postId, {
      $inc: { upvotes: -1 },
    });

    user.upvotedPosts = user.upvotedPosts.filter(
      (item) => item.toString() !== postId
    );

    await user.save();

    return res
      .status(200)
      .json(
        new ApiResponse(
          200,
          { updatedPost, user },
          "Post was already upvoted, so removed it from upvotedPosts"
        )
      );
  }

  let updatedPost;

  // If user has downvoted the post before, we remove that here
  if (user?.downvotedPosts.includes(postId)) {
    updatedPost = await Post.findByIdAndUpdate(postId, {
      $inc: { upvotes: +1, downvotes: -1 },
    });
    user.downvotedPosts = user.downvotedPosts.filter(
      (item) => item.toString() !== postId
    );
  } else {
    updatedPost = await Post.findByIdAndUpdate(postId, {
      $inc: { upvotes: +1 },
    });
  }

  if (!updatedPost) {
    throw new ApiError(404, "Post with this id does not exist");
  }

  user?.upvotedPosts.push(postId);
  await user?.save();

  return res
    .status(200)
    .json(
      new ApiResponse(200, { updatedPost, user }, "Post upvoted successfully")
    );
});

export const downvotePost = asyncHandler(async (req: UserRequest, res) => {
  const { postId } = req.body;
  const user = req.user;

  if (!postId) {
    throw new ApiError(400, "Post id is required to downvote the post");
  }

  // Remove the downvote
  if (user?.downvotedPosts.includes(postId)) {
    const updatedPost = await Post.findByIdAndUpdate(postId, {
      $inc: { downvotes: -1 },
    });

    user.downvotedPosts = user.downvotedPosts.filter(
      (item) => item.toString() !== postId
    );

    await user.save();

    return res
      .status(200)
      .json(
        new ApiResponse(
          200,
          { updatedPost, user },
          "Post was downvoted already, so removing the downvote instead"
        )
      );
  }

  let updatedPost;

  // If user has upvoted the post before, we remove that here
  if (user?.upvotedPosts.includes(postId)) {
    updatedPost = await Post.findByIdAndUpdate(postId, {
      $inc: { downvotes: +1, upvotes: -1 },
    });

    user.upvotedPosts = user.upvotedPosts.filter(
      (item) => item.toString() !== postId
    );
  } else {
    updatedPost = await Post.findByIdAndUpdate(postId, {
      $inc: { downvotes: +1 },
    });
  }

  if (!updatedPost) {
    throw new ApiError(404, "Post with this id does not exist");
  }

  user?.downvotedPosts.push(postId);
  await user?.save();

  return res
    .status(200)
    .json(
      new ApiResponse(200, { updatedPost, user }, "Post downvoted successfully")
    );
});

// FIXME: Change this to toggle save or make a new controller for toggle save
export const savePost = asyncHandler(async (req: UserRequest, res) => {
  const { postId } = req.body;
  const user = req.user;

  if (!postId) {
    throw new ApiError(400, "Post id is required to save posts");
  }

  if (user?.savedPosts?.includes(postId)) {
    throw new ApiError(400, "You have already saved this post");
  }

  user?.savedPosts?.push(postId);

  await user?.save();

  return res
    .status(200)
    .json(new ApiResponse(200, { user }, "Post saved successfully"));
});

export const getSavedPosts = asyncHandler(async (req: UserRequest, res) => {
  const user = req.user;

  const savedPosts = await Post.find({
    _id: { $in: user?.savedPosts },
  });

  return res
    .status(200)
    .json(new ApiResponse(200, savedPosts, "Saved posts sent successfully"));
});

export const removeSavedPost = asyncHandler(async (req: UserRequest, res) => {
  const { postId } = req.body;
  const user = req.user;

  if (!postId)
    throw new ApiError(400, "Post id is required to remove saved post");

  if (!user?.savedPosts?.includes(postId)) {
    throw new ApiError(400, "You haven't saved this post yet");
  }

  user.savedPosts = user.savedPosts.filter(
    (item) => item.toString() !== postId
  );

  await user.save();

  return res
    .status(200)
    .json(new ApiResponse(200, { user }, "Post removed successfully"));
});

export const getUpvotedPosts = asyncHandler(async (req: UserRequest, res) => {
  const user = req.user;

  if (user?.upvotedPosts.length === 0) {
    throw new ApiError(404, "You don't have any upvoted posts");
  }

  let upvotedPosts = await Post.find({
    _id: { $in: user?.upvotedPosts },
  });

  upvotedPosts = upvotedPosts.reverse();

  return res
    .status(200)
    .json(
      new ApiResponse(200, upvotedPosts, "Upvoted posts sent successfully")
    );
});

export const getDownvotedPosts = asyncHandler(async (req: UserRequest, res) => {
  const user = req.user;

  if (user?.downvotedPosts.length === 0) {
    throw new ApiError(404, "You don't have any downvoted posts");
  }

  let downvotedPosts = await Post.find({
    _id: { $in: user?.downvotedPosts },
  });

  downvotedPosts = downvotedPosts.reverse();

  return res
    .status(200)
    .json(
      new ApiResponse(200, downvotedPosts, "Downvoted posts sent successfully")
    );
});

// TODO: when OP deletes post, make sure to remove that post from all the other users upvoted posts, downvoted posts and saved posts.
export const deletePost = asyncHandler(async (req: UserRequest, res) => {
  const { postId } = req.body;
  const user = req.user;

  if (!postId)
    throw new ApiError(400, "Post id is required to delete the post");

  const postToDelete = await Post.findById(postId);

  if (postToDelete?.madeBy.username !== user?.username) {
    throw new ApiError(
      401,
      "Cannot delete post as this post hasn't been created by you"
    );
  }

  const post = await Post.deleteOne({ _id: postId });

  if (!post) throw new ApiError(404, "Post with this id does not exist");

  return res
    .status(200)
    .json(new ApiResponse(200, { post }, "Post deleted successfully"));
});

export const updatePost = asyncHandler(async (req: UserRequest, res) => {
  const { postId, title, description, content, language } = req.body;
  const user = req.user;

  if (!postId) throw new ApiError(400, "Post id is required to update post");

  const post = await Post.findById(postId);
  if (!post) throw new ApiError(404, "Post with this id does not exist");
  if (post.madeBy.username !== user?.username) {
    throw new ApiError(
      401,
      "Cannot update post as this post hasn't been created by you"
    );
  }

  if (title) post.title = title;
  if (description) post.description = description;
  if (content) post.content = content;
  if (language) {
    if (!allowedLanguages.includes(language)) {
      throw new ApiError(400, "This language is not supported yet");
    }
    post.language = language;
  }

  await post.save();

  return res
    .status(200)
    .json(new ApiResponse(200, { post }, "Post updated successfully"));
});

export const searchPosts = asyncHandler(async (req, res) => {
  const { query } = req.query;

  // query validation
  // TODO: do this with zod
  if (!query || typeof query !== "string") {
    throw new ApiError(400, "Query is required and must be a string");
  }

  const posts = await Post.find({
    $text: { $search: query },
  });

  return res
    .status(200)
    .json(new ApiResponse(200, posts, "Posts sent successfully"));
});



================================================
FILE: backend/src/controllers/user.controllers.ts
================================================
import { Response } from "express";
import { generateUsername } from "unique-username-generator";

import { cookieOptions } from "../constants";
import { User, UserTypes } from "../models/user.model";
import { UserRequest } from "../types/userTypes";
import { ApiError } from "../utils/apiError";
import { ApiResponse } from "../utils/apiResponse";
import { asyncHandler } from "../utils/asyncHandler";
import { uploadOnCloudinary } from "../utils/cloudinary";
import { Post } from "../models/post.model";
import { Comment } from "../models/comment.model";
import { Community } from "../models/community.model";

const generateAccessAndRefreshTokens = async (userId: string) => {
  try {
    const user = (await User.findById(userId)) as UserTypes;
    const accessToken = user.generateAccessToken();
    const refreshToken = user.generateRefreshToken();

    user.refreshToken = refreshToken;
    await user.save({ validateBeforeSave: false });

    return { accessToken, refreshToken };
  } catch (error) {
    throw new ApiError(
      500,
      "Something went wrong while generating access and refresh tokens"
    );
  }
};

export const registerUser = asyncHandler(
  async (req: UserRequest, res: Response) => {
    const { firstName, lastName, email, password } = req.body;

    if (!firstName) throw new ApiError(400, "Firstname is required");
    if (!lastName) throw new ApiError(400, "Lastname is required");
    if (!password) throw new ApiError(400, "Password is required");
    if (!email) throw new ApiError(400, "Email is required");

    const emailExists = await User.findOne({ email });
    if (emailExists) throw new ApiError(409, "Email has already been used");

    const username = generateUsername("-", 0);

    const user = await User.create({
      firstName,
      lastName,
      username,
      email,
      password,
      communitiesJoined: ["all"],
    });

    const createdUser = await User.findById(user._id).select(
      "-password -refreshToken"
    );

    if (!createdUser)
      throw new ApiError(
        500,
        "Something went wrong while registering the user"
      );

    return res
      .status(201)
      .json(new ApiResponse(201, createdUser, "User registered sucessfully"));
  }
);

export const loginUser = asyncHandler(
  async (req: UserRequest, res: Response) => {
    const { email, password } = req.body;

    if (!email) throw new ApiError(400, "Email required");
    if (!password) throw new ApiError(400, "Password required");

    const user = await User.findOne({ email });

    if (!user) throw new ApiError(404, "User not found");

    const isPasswordValid = await user.isPasswordCorrect(password);

    if (!isPasswordValid) throw new ApiError(401, "Invalid Password");

    const { accessToken, refreshToken } = await generateAccessAndRefreshTokens(
      user._id
    );

    const loggedInUser = await User.findById(user._id).select(
      "-password -refreshToken"
    );

    return res
      .status(200)
      .cookie("accessToken", accessToken, cookieOptions)
      .cookie("refreshToken", refreshToken, cookieOptions)
      .json(
        new ApiResponse(
          200,
          {
            user: loggedInUser,
            accessToken,
            refreshToken,
          },
          "User logged in successfully"
        )
      );
  }
);

export const logoutUser = asyncHandler(
  async (req: UserRequest, res: Response) => {
    const user = req.user;

    if (!user) {
      throw new ApiError(400, "User doesn't exist");
    }

    await User.findByIdAndUpdate(
      user._id,
      {
        $set: {
          refreshToken: undefined,
        },
      },
      {
        new: true,
      }
    );

    return res
      .status(200)
      .clearCookie("accessToken", cookieOptions)
      .clearCookie("refreshToken", cookieOptions)
      .json(new ApiResponse(200, {}, "User logged out"));
  }
);

export const getCurrentUser = asyncHandler(
  async (req: UserRequest, res: Response) => {
    return res
      .status(200)
      .json(
        new ApiResponse(200, { user: req.user }, "User fetched successfully")
      );
  }
);

export const getUserProfile = asyncHandler(async (req, res) => {
  const { username } = req.body;

  // FIXME: add zod verification here
  if (!username) throw new ApiError(400, "Username is required");

  const user = await User.findOne({ username }).select(
    "-password -refreshToken -email"
  );

  if (!user) throw new ApiError(404, "User not found");

  return res
    .status(200)
    .json(new ApiResponse(200, user, "User sent successfully"));
});

export const updateUsername = asyncHandler(async (req: UserRequest, res) => {
  const { newUsername } = req.body;
  const user = req.user;

  if (!newUsername) throw new ApiError(400, "New username is required");

  if (newUsername === user?.username)
    throw new ApiError(400, "New username can't be the same as old username");

  const userExists = await User.findOne({ username: newUsername });
  if (userExists)
    throw new ApiError(409, "User with this username already exists");

  // Updating posts, comments and communities made by the user
  await Post.updateMany(
    { "madeBy.username": user?.username },
    { $set: { "madeBy.username": newUsername } }
  );

  await Comment.updateMany(
    { "madeBy.username": user?.username },
    { $set: { "madeBy.username": newUsername } }
  );

  await Community.updateMany(
    { "madeBy.username": user?.username },
    { $set: { "madeBy.username": newUsername } }
  );

  user!.username = newUsername;
  await user?.save();

  return res
    .status(200)
    .json(
      new ApiResponse(
        200,
        { updatedUser: user },
        "Username updated successfully"
      )
    );
});

export const uploadAvatar = asyncHandler(async (req: UserRequest, res) => {
  const avatarLocalPath = req?.file?.path;
  const user = req.user;

  if (!avatarLocalPath) throw new ApiError(400, "Avatar file is required");

  const avatar = await uploadOnCloudinary(avatarLocalPath);

  if (!avatar) throw new ApiError(400, "Avatar file is required");

  const updatedUser = await User.findByIdAndUpdate(
    user?._id,
    { avatar: avatar.url },
    { new: true }
  ).select("-password -refreshToken");

  if (!updatedUser)
    throw new ApiError(500, "Something went wrong uploading avatar");

  return res
    .status(200)
    .json(
      new ApiResponse(200, { user: updatedUser }, "Avatar uploaded sucessfully")
    );
});

export const changeCurrentPassword = asyncHandler(
  async (req: UserRequest, res) => {
    const { oldPassword, newPassword } = req.body;

    if (!oldPassword || !newPassword)
      throw new ApiError(400, "Both old and new passwords are required");

    const user = await User.findById(req.user?._id);
    const isPasswordCorrect = await user?.isPasswordCorrect(oldPassword);

    if (!isPasswordCorrect) {
      throw new ApiError(401, "Invalid old password");
    }

    user!.password = newPassword;
    await user?.save({ validateBeforeSave: false });

    return res
      .status(200)
      .json(new ApiResponse(200, {}, "Password changed successfully"));
  }
);

export const setUserDownloadPath = asyncHandler(
  async (req: UserRequest, res) => {
    const { downloadPath } = req.body;
    const user = req.user!;

    if (!downloadPath) throw new ApiError(400, "Download path is required");

    user.downloadPath = downloadPath;
    await user?.save();

    return res
      .status(200)
      .json(
        new ApiResponse(
          200,
          { updatedUser: user },
          "Download path set sucessfully"
        )
      );
  }
);



================================================
FILE: backend/src/controllers/__tests__/healthCheck.controller.test.ts
================================================



================================================
FILE: backend/src/db/db.ts
================================================
import mongoose from "mongoose";
import { DB_NAME } from "../constants";
import logger from "../utils/logger";

async function connectDB() {
  try {
    const connectionInstance = await mongoose.connect(
      `${process.env.MONGO_URL}/${DB_NAME}`,
      {
        writeConcern: { w: "majority" },
      }
    );
    logger.info(
      `MongoDB connected - DB HOST: ${connectionInstance.connection.host}`
    );
    logger.info(`DB PORT: ${connectionInstance.connection.port}`);
    logger.info(`DB NAME: ${connectionInstance.connection.name}`);
  } catch (error) {
    logger.error("MONGODB connection error: ");
    throw error;
  }
}

export default connectDB;



================================================
FILE: backend/src/middlewares/auth.middleware.ts
================================================
import { NextFunction, Response } from "express";
import jwt from "jsonwebtoken";

import { User } from "../models/user.model";
import { UserRequest } from "../types/userTypes";
import { ApiError } from "../utils/apiError";
import { asyncHandler } from "../utils/asyncHandler";

interface JwtPayload {
  _id: string;
}

export const verifyJWT = asyncHandler(
  async (req: UserRequest, res: Response, next: NextFunction) => {
    try {
      const token =
        req.cookies?.accessToken ||
        req.header("Authorization")?.replace("Bearer ", "");

      if (!token) throw new ApiError(401, "Unauthorized request");

      const decodedToken = jwt.verify(
        token,
        process.env.ACCESS_TOKEN_SECRET!,
      ) as JwtPayload;

      const user = await User.findById(decodedToken?._id).select(
        "-password -refreshToken",
      );

      if (!user) throw new ApiError(401, "Invalid Access Token");

      req.user = user;
      next();
    } catch (error) {
      throw new ApiError(
        401,
        (error as Error).message || "Invalid access token",
      );
    }
  },
);



================================================
FILE: backend/src/middlewares/multer.middleware.ts
================================================
import multer from "multer";

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "./public/temp");
  },
  filename: function (req, file, cb) {
    cb(null, file.originalname);
  },
});

export const upload = multer({ storage });



================================================
FILE: backend/src/models/comment.model.ts
================================================
import mongoose, { Document, Schema } from "mongoose";

export interface CommentTypes extends Document {
  madeBy: {
    userId: Schema.Types.ObjectId;
    username: string;
  };
  parent: Schema.Types.ObjectId;
  type: "comment" | "reply";
  content: string;
  upvotes: number;
  downvotes: number;
  isEdited: boolean;
}

const commentSchema: Schema<CommentTypes> = new Schema(
  {
    madeBy: {
      userId: {
        type: Schema.Types.ObjectId,
        ref: "User",
        required: true,
        // unique: true,
      },
      username: {
        type: String,
        trim: true,
        required: true,
        // unique: true,
      },
    },
    parent: {
      type: Schema.Types.ObjectId,
      ref: "Comment" || "Post",
      required: true,
    },
    type: {
      type: String,
      required: true,
      default: "comment",
    },
    content: {
      type: String,
      required: true,
    },
    upvotes: {
      type: Number,
      default: 0,
    },
    downvotes: {
      type: Number,
      default: 0,
    },
    isEdited: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true },
);

export const Comment = mongoose.model("Comment", commentSchema);



================================================
FILE: backend/src/models/community.model.ts
================================================
import mongoose, { Document, Schema } from "mongoose";

export interface CommunityTypes extends Document {
  madeBy: {
    userId: Schema.Types.ObjectId;
    username: string;
  };
  name: string;
  description: string;
  joinedMembers: number;
  coverImage: string;
  avatar: string;
}

const communitySchema: Schema<CommunityTypes> = new Schema(
  {
    madeBy: {
      userId: {
        type: Schema.Types.ObjectId,
        ref: "User",
        required: true,
        // unique: true,
      },
      username: {
        type: String,
        trim: true,
        required: true,
        // unique: true,
      },
    },
    name: {
      type: String,
      required: true,
      unique: true,
      trim: true,
    },
    description: {
      type: String,
      trim: true,
      required: true,
    },
    joinedMembers: {
      type: Number,
      default: 1,
    },
    coverImage: { type: String },
    avatar: { type: String },
  },
  { timestamps: true },
);

export const Community = mongoose.model("Community", communitySchema);



================================================
FILE: backend/src/models/post.model.ts
================================================
import mongoose, { Document, Schema } from "mongoose";

import { CommentTypes } from "./comment.model";

export const allowedLanguages = [
  "javascript",
  "python",
  "typescript",
  "ruby",
  "java",
  "csharp",
  "cpp",
  "go",
  "php",
  "swift",
] as const;

type Language = (typeof allowedLanguages)[number];

export interface PostTypes extends Document {
  content: string;
  language: Language;
  community: string;
  title: string;
  upvotes: number;
  downvotes: number;
  description: string;
  madeBy: {
    userId: Schema.Types.ObjectId;
    fullname: string;
    username: string;
  };
  comments?: CommentTypes[];
}

const postSchema: Schema<PostTypes> = new Schema(
  {
    madeBy: {
      userId: {
        type: Schema.Types.ObjectId,
        ref: "User",
        required: true,
      },
      fullname: {
        type: String,
        trim: true,
        required: true,
      },
      username: {
        type: String,
        trim: true,
        required: true,
      },
    },
    content: {
      type: String,
      required: true,
    },
    language: {
      type: String,
      required: true,
      enum: allowedLanguages,
    },
    comments: [
      {
        type: Schema.Types.ObjectId,
        ref: "Comment",
      },
    ],
    community: { type: String, required: true, default: "all" },
    title: { type: String, required: true },
    description: { type: String, required: true },
    upvotes: { type: Number, default: 0 },
    downvotes: { type: Number, default: 0 },
  },
  { timestamps: true }
);

// to search by title, content and description
postSchema.index(
  { title: "text", content: "text", description: "text" },
  { language_override: "none" }
);

const Post = mongoose.model<PostTypes>("Post", postSchema);
Post.createIndexes();

export { Post };



================================================
FILE: backend/src/models/user.model.ts
================================================
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import mongoose, { Document, Schema } from "mongoose";

export interface UserTypes extends Document {
  _id: string;
  username: string;
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  refreshToken: string;
  upvotedPosts: Schema.Types.ObjectId[];
  downvotedPosts: Schema.Types.ObjectId[];
  savedPosts: Schema.Types.ObjectId[];
  upvotedComments: Schema.Types.ObjectId[];
  downvotedComments: Schema.Types.ObjectId[];
  communitiesJoined: string[];
  verifyCode?: string;
  verifyCodeExpiry?: Date;
  isVerified: boolean;
  avatar: string;
  downloadPath: string;
  generateRefreshToken: () => string;
  generateAccessToken: () => string;
  isPasswordCorrect: (password: string) => Promise<boolean>;
}

const userSchema: Schema<UserTypes> = new Schema(
  {
    username: {
      type: String,
      required: [true, "Username is required"],
      unique: true,
      trim: true,
    },
    email: {
      type: String,
      required: [true, "Email is required"],
      unique: true,
      match: [
        /\b[\w\.-]+@[\w\.-]+\.\w{2,4}\b/gi,
        "Please use a valid email address",
      ],
    },
    password: {
      type: String,
      required: [true, "Password is requird"],
    },
    firstName: {
      type: String,
      required: [true, "First name is required"],
      trim: true,
      index: true,
    },
    lastName: {
      type: String,
      required: [true, "Last name is required"],
      trim: true,
      index: true,
    },
    refreshToken: {
      type: String,
    },
    upvotedPosts: [
      {
        type: Schema.Types.ObjectId,
        ref: "Post",
      },
    ],
    downvotedPosts: [
      {
        type: Schema.Types.ObjectId,
        ref: "Post",
      },
    ],
    upvotedComments: [
      {
        type: Schema.Types.ObjectId,
        ref: "Comment",
      },
    ],
    downvotedComments: [
      {
        type: Schema.Types.ObjectId,
        ref: "Comment",
      },
    ],
    savedPosts: [
      {
        type: Schema.Types.ObjectId,
        ref: "Post",
      },
    ],
    // TODO: Add this feature
    // verifyCode: {
    //   type: String,
    //   required: [true, "Verify code is required"],
    // },
    // verifyCodeExpiry: {
    //   type: Date,
    //   required: [true, "Verify code expiry is required"],
    // },
    isVerified: {
      type: Boolean,
      default: false,
    },
    communitiesJoined: [
      {
        type: String,
        default: "all",
      },
    ],
    avatar: {
      type: String,
    },
    downloadPath: {
      type: String,
      trim: true,
    },
  },
  {
    timestamps: true,
  }
);

userSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

userSchema.methods.isPasswordCorrect = async function (password: string) {
  return await bcrypt.compare(password, this.password);
};

userSchema.methods.generateAccessToken = function () {
  return jwt.sign(
    {
      _id: this._id,
      email: this.email,
      fullName: this.fullName,
    },
    process.env.ACCESS_TOKEN_SECRET!,
    {
      expiresIn: process.env.ACCESS_TOKEN_EXPIRY,
    }
  );
};

userSchema.methods.generateRefreshToken = function () {
  return jwt.sign(
    {
      _id: this._id,
    },
    process.env.REFRESH_TOKEN_SECRET!,
    {
      expiresIn: process.env.REFRESH_TOKEN_EXPIRY,
    }
  );
};

export const User = mongoose.model<UserTypes>("User", userSchema);



================================================
FILE: backend/src/routes/ai.routes.ts
================================================
import { Router } from "express";
import { verifyJWT } from "../middlewares/auth.middleware";
import { getAiAnswer } from "../controllers/ai.controller";

const router = Router();

// routes without auth

// secure posts
router.route("/explain").get(verifyJWT, getAiAnswer);

export default router;



================================================
FILE: backend/src/routes/comment.routes.ts
================================================
import { Router } from "express";

import {
  createComment,
  deleteComment,
  downvoteComment,
  getComments,
  updateComment,
  upvoteComment,
} from "../controllers/comment.controllers";
import { verifyJWT } from "../middlewares/auth.middleware";

const router = Router();

// routes without auth
router.route("/get-comments").post(getComments);

// secure posts
router.route("/create-comment").put(verifyJWT, createComment);
router.route("/upvote").patch(verifyJWT, upvoteComment);
router.route("/downvote").patch(verifyJWT, downvoteComment);
router.route("/update-comment").patch(verifyJWT, updateComment); // Added route for updating a comment
router.route("/delete-comment").post(verifyJWT, deleteComment);

export default router;



================================================
FILE: backend/src/routes/community.routes.ts
================================================
import { Router } from "express";
import {
  createCommunity,
  getCommunities,
  getCommunity,
  joinCommunity,
  leaveCommunity,
  updateCommunityInfo,
  uploadAvatar,
  uploadCoverImage,
} from "../controllers/community.controllers";
import { verifyJWT } from "../middlewares/auth.middleware";
import { upload } from "../middlewares/multer.middleware";

const router = Router();

// routes without auth
router.route("/get-all").get(getCommunities);
router.route("/get-community").post(getCommunity);

// secure posts
router.route("/create-community").post(verifyJWT, createCommunity);
router.route("/join").post(verifyJWT, joinCommunity);
router.route("/leave").post(verifyJWT, leaveCommunity);
router
  .route("/upload-avatar")
  .post(verifyJWT, upload.single("avatar"), uploadAvatar);
router
  .route("/upload-cover-image")
  .post(verifyJWT, upload.single("cover-image"), uploadCoverImage);
router.route("/update-info").put(verifyJWT, updateCommunityInfo);

export default router;



================================================
FILE: backend/src/routes/healthCheck.routes.ts
================================================
import { Router } from "express";

import { healthCheck } from "../controllers/healthCheck.controller";

const router = Router();

// secure routes
router.route("/health-check").get(healthCheck);

export default router;



================================================
FILE: backend/src/routes/post.routes.ts
================================================
import { Router } from "express";

import {
  createPost,
  deletePost,
  downvotePost,
  getDownvotedPosts,
  getPost,
  getPosts,
  getPostsByCommunity,
  getPostsByLang,
  getPostsByUsername,
  getSavedPosts,
  getUpvotedPosts,
  removeSavedPost,
  savePost,
  searchPosts,
  updatePost,
  upvotePost,
} from "../controllers/post.controllers";
import { verifyJWT } from "../middlewares/auth.middleware";

const router = Router();

// routes without auth
router.route("/get-posts").get(getPosts);
router.route("/get-posts-by-language").post(getPostsByLang);
router.route("/get-post").post(getPost);
router.route("/get-posts-by-username").post(getPostsByUsername);
router.route("/get-posts-by-community").post(getPostsByCommunity);
router.route("/search").get(searchPosts);

// secure posts
router.route("/create-post").post(verifyJWT, createPost);
router.route("/upvote").patch(verifyJWT, upvotePost);
router.route("/downvote").patch(verifyJWT, downvotePost);
router.route("/save").post(verifyJWT, savePost);
router.route("/get-saved-posts").get(verifyJWT, getSavedPosts);
router.route("/remove-saved-post").patch(verifyJWT, removeSavedPost);
router.route("/get-upvoted").get(verifyJWT, getUpvotedPosts);
router.route("/get-downvoted").get(verifyJWT, getDownvotedPosts);
router.route("/delete-post").post(verifyJWT, deletePost);
router.route("/update-post").patch(verifyJWT, updatePost);

export default router;



================================================
FILE: backend/src/routes/user.routes.ts
================================================
import { Router } from "express";

import {
  changeCurrentPassword,
  getCurrentUser,
  getUserProfile,
  loginUser,
  logoutUser,
  registerUser,
  setUserDownloadPath,
  updateUsername,
  uploadAvatar,
} from "../controllers/user.controllers";
import { verifyJWT } from "../middlewares/auth.middleware";
import { upload } from "../middlewares/multer.middleware";

const router = Router();

router.route("/register").post(registerUser);
router.route("/login").post(loginUser);
router.route("/get-user-profile").post(getUserProfile);

// secured routes
router.route("/logout").post(verifyJWT, logoutUser);
router.route("/get-current-user").get(verifyJWT, getCurrentUser);
router.route("/update-username").patch(verifyJWT, updateUsername);
router.route("/update-password").patch(verifyJWT, changeCurrentPassword);
router
  .route("/upload-avatar")
  .post(verifyJWT, upload.single("avatar"), uploadAvatar);
router.route("/set-download-path").patch(verifyJWT, setUserDownloadPath);

export default router;



================================================
FILE: backend/src/schemas/communitySchema.ts
================================================
import { z } from "zod";

export const communityNameSchema = z
  .string()
  .min(3, { message: "Subreddit name must be at least 3 characters long" })
  .max(21, { message: "Subreddit name must be at most 21 characters long" })
  .regex(/^[a-zA-Z0-9]([a-zA-Z0-9_-]*[a-zA-Z0-9])?$/, {
    message:
      "Subreddit name can only contain letters, numbers, underscores, and hyphens, but must not start or end with a hyphen or underscore",
  });



================================================
FILE: backend/src/schemas/postSchema.ts
================================================
import { z } from "zod";

import { allowedLanguages } from "../models/post.model";

export const postSchema = z.object({
  title: z.string().max(200).trim(),
  language: z.enum(allowedLanguages),
  content: z.string().max(10000),
  description: z.string().max(40000).trim(),
  community: z.string().trim().optional(),
});



================================================
FILE: backend/src/types/userTypes.ts
================================================
import { Request } from "express";

import { UserTypes } from "../models/user.model";

export interface UserRequest extends Request {
  user?: UserTypes;
}



================================================
FILE: backend/src/utils/apiError.ts
================================================
class ApiError extends Error {
  statusCode: number;
  data: object | null;
  success: boolean;
  errors: any[];

  constructor(
    statusCode: number,
    message = "Something went wrong",
    errors: any[] = [],
    stack = "",
  ) {
    super(message);
    this.statusCode = statusCode;
    this.data = null;
    this.message = message;
    this.success = false;
    this.errors = errors;

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

export { ApiError };



================================================
FILE: backend/src/utils/apiResponse.ts
================================================
class ApiResponse {
  statusCode: number;
  data: object;
  message: string;
  success: boolean;

  constructor(statusCode: number, data: object, message = "success") {
    this.statusCode = statusCode;
    this.data = data;
    this.message = message;
    this.success = statusCode < 400;
  }
}

export { ApiResponse };



================================================
FILE: backend/src/utils/asyncHandler.ts
================================================
import { NextFunction, Request, RequestHandler, Response } from "express";

const asyncHandler = (requestHandler: RequestHandler): RequestHandler => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(requestHandler(req, res, next)).catch((err) => next(err));
  };
};

export { asyncHandler };



================================================
FILE: backend/src/utils/cloudinary.ts
================================================
import { v2 as cloudinary } from "cloudinary";
import fs from "fs";

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

const uploadOnCloudinary = async (localFilePath: string) => {
  try {
    if (!localFilePath) return null;
    const response = await cloudinary.uploader.upload(localFilePath, {
      resource_type: "auto",
    });

    // console.log(
    //   "File has been successfully uploaded on cloudinary",
    //   response.url
    // );

    fs.unlinkSync(localFilePath);
    return response;
  } catch (error) {
    fs.unlinkSync(localFilePath); // remove temp file as upload operation failed
    return null;
  }
};

export { uploadOnCloudinary };



================================================
FILE: backend/src/utils/logger.ts
================================================
import pino from "pino";

const logger = pino();

export default logger;



================================================
FILE: backend/src/utils/ratelimit.ts
================================================
import { Ratelimit } from "@unkey/ratelimit";

if (!process.env.UNKEY_ROOT_KEY) {
  throw new Error("UNKEY_ROOT_KEY is not set");
}

export const limiter = new Ratelimit({
  namespace: "codestash",
  limit: 10,
  duration: "60s",
  rootKey: process.env.UNKEY_ROOT_KEY,
});



================================================
FILE: frontend/README.md
================================================
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.



================================================
FILE: frontend/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}



================================================
FILE: frontend/next.config.mjs
================================================
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "skillicons.dev",
      },
    ],
  },
  experimental: {
    missingSuspenseWithCSRBailout: false,
  },
};

import withBundleAnalyzer from "@next/bundle-analyzer";

const bundleAnalyzer = withBundleAnalyzer({
  enabled: process.env.ANALYZE === "true",
});

export default bundleAnalyzer(nextConfig);



================================================
FILE: frontend/package.json
================================================
{
  "name": "codestash",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "format": "prettier --write src/",
    "prepare": "cd .. && husky frontend/.husky"
  },
  "dependencies": {
    "@formbricks/js": "^3.0.2",
    "@formkit/auto-animate": "^0.8.2",
    "@heroui/react": "2.7.6",
    "@next/bundle-analyzer": "15.0.1",
    "@radix-ui/react-alert-dialog": "^1.1.14",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-toast": "^1.2.14",
    "@tanstack/react-query": "^5.81.2",
    "@uidotdev/usehooks": "^2.4.1",
    "@uiw/react-markdown-preview": "^5.1.4",
    "@uiw/react-textarea-code-editor": "^3.1.1",
    "axios": "^1.10.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^11.18.2",
    "markdown-to-jsx": "^7.7.8",
    "next": "14.2.3",
    "next-themes": "^0.3.0",
    "react": "^18.1.0",
    "react-dom": "^18.1.0",
    "react-hot-toast": "^2.5.2",
    "react-icons": "^5.5.0",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.9",
    "zustand": "^4.5.7"
  },
  "devDependencies": {
    "@tanstack/eslint-plugin-query": "^5.81.2",
    "@tanstack/react-query-devtools": "^5.81.2",
    "@types/node": "^20.19.1",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "eslint": "^8.57.1",
    "eslint-config-next": "15.0.1",
    "husky": "^9.1.7",
    "postcss": "^8.5.6",
    "prettier": "^3.6.2",
    "prettier-plugin-organize-imports": "^4.1.0",
    "prettier-plugin-tailwindcss": "^0.6.13",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.8.3"
  },
  "pnpm": {
    "overrides": {
      "@types/react": "npm:types-react@19.0.0-rc.1",
      "@types/react-dom": "npm:types-react-dom@19.0.0-rc.1"
    }
  }
}


================================================
FILE: frontend/postcss.config.mjs
================================================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;



================================================
FILE: frontend/tailwind.config.ts
================================================
import type { Config } from "tailwindcss";
import { fontFamily } from "tailwindcss/defaultTheme";

const { heroui } = require("@heroui/react");

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
    "./node_modules/@heroui/theme/dist/**/*.{js,ts,jsx,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        enter: {
          "0%": { transform: "scale(0.9)", opacity: "0" },
          "100%": { transform: "scale(1)", opacity: "1" },
        },
        leave: {
          "0%": { transform: "scale(1)", opacity: "1" },
          "100%": { transform: "scale(0.9)", opacity: "0" },
        },
        "slide-in": {
          "0%": { transform: "translateY(-100%)" },
          "100%": { transform: "translateY(0)" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        enter: "enter 200ms ease-out",
        "slide-in": "slide-in 1.2s cubic-bezier(.41,.73,.51,1.02)",
        leave: "leave 150ms ease-in forwards",
      },
      fontFamily: {
        sans: ["var(--font-sans)", ...fontFamily.sans],
      },
    },
  },
  plugins: [require("tailwindcss-animate"), heroui()],
} satisfies Config;

export default config;



================================================
FILE: frontend/tsconfig.json
================================================
{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "target": "ES2017"
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}



================================================
FILE: frontend/.eslintrc.json
================================================
{
  "extends": "next/core-web-vitals"
}



================================================
FILE: frontend/.npmrc
================================================
public-hoist-pattern[]=*@heroui/*


================================================
FILE: frontend/.prettierignore
================================================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts



================================================
FILE: frontend/.prettierrc
================================================
{
  "plugins": ["prettier-plugin-tailwindcss", "prettier-plugin-organize-imports"]
}



================================================
FILE: frontend/src/app/formbricks.tsx
================================================
"use client";

import formbricks from "@formbricks/js";
import { usePathname, useSearchParams } from "next/navigation";
import { useEffect } from "react";

export default function FormbricksProvider() {
  const pathname = usePathname();
  const searchParams = useSearchParams();

  useEffect(() => {
    formbricks.init({
      environmentId: "cm29bfc8s0002r5vrwh5oyfjk",
      apiHost: "https://app.formbricks.com",
    });
  }, []);

  useEffect(() => {
    formbricks?.registerRouteChange();
  }, [pathname, searchParams]);

  return null;
}



================================================
FILE: frontend/src/app/globals.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 221.2 100% 95%;
  --foreground: 221.2 5% 10%;
  --card: 221.2 50% 90%;
  --card-foreground: 221.2 5% 15%;
  --popover: 221.2 100% 95%;
  --popover-foreground: 221.2 100% 10%;
  --primary: 221.2 83.2% 53.3%;
  --primary-foreground: 0 0% 100%;
  --secondary: 221.2 30% 70%;
  --secondary-foreground: 0 0% 0%;
  --muted: 183.2 30% 85%;
  --muted-foreground: 221.2 5% 35%;
  --accent: 183.2 30% 80%;
  --accent-foreground: 221.2 5% 15%;
  --destructive: 0 100% 30%;
  --destructive-foreground: 221.2 5% 90%;
  --border: 221.2 30% 50%;
  --input: 221.2 30% 20%;
  --ring: 221.2 83.2% 53.3%;
  --radius: 1rem;
  --next-blue: #c7d7fc;
}

.dark {
  --background: 221.2 50% 10%;
  --foreground: 221.2 5% 90%;
  --card: 221.2 50% 10%;
  --card-foreground: 221.2 5% 90%;
  --popover: 221.2 50% 5%;
  --popover-foreground: 221.2 5% 90%;
  --primary: 221.2 83.2% 53.3%;
  --primary-foreground: 0 0% 100%;
  --secondary: 221.2 30% 20%;
  --secondary-foreground: 0 0% 100%;
  --muted: 183.2 30% 20%;
  --muted-foreground: 221.2 5% 60%;
  --accent: 183.2 30% 20%;
  --accent-foreground: 221.2 5% 90%;
  --destructive: 0 100% 30%;
  --destructive-foreground: 221.2 5% 90%;
  --border: 221.2 30% 20%;
  --input: 221.2 30% 20%;
  --ring: 221.2 83.2% 53.3%;
  --radius: 1rem;
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

body {
  padding: 1rem !important;
}

html {
  scroll-behavior: smooth !important;
}



================================================
FILE: frontend/src/app/layout.tsx
================================================
import type { Metadata } from "next";
import "./globals.css";

import { Inter as FontSans } from "next/font/google";

import FormbricksProvider from "@/app/formbricks";
import Dashboard from "@/components/Dashboard";
import { ThemeProvider } from "@/components/theme-provider";
import { Toaster } from "@/components/ui/toaster";

import { cn } from "@/lib/utils";
import { HeroUIProvider } from "@heroui/react";
import { Toaster as RHToaster } from "react-hot-toast";
import Providers from "./providers";

const fontSans = FontSans({
  subsets: ["latin"],
  variable: "--font-sans",
});

export const metadata: Metadata = {
  title: "CodeStash",
  description: "The best solution for keeping code snippets",
  icons: {
    icon: "/favicon.png",
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={cn(
          "min-h-screen bg-background p-4 font-sans antialiased",
          fontSans.variable,
        )}
      >
        <FormbricksProvider />
        <ThemeProvider
          attribute="class"
          defaultTheme="light"
          enableSystem
          disableTransitionOnChange
        >
          <HeroUIProvider>
            <Providers>
              <Dashboard>
                <main className="h-full w-full">{children}</main>
              </Dashboard>
            </Providers>
            <Toaster />
            <RHToaster />
          </HeroUIProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}



================================================
FILE: frontend/src/app/page.tsx
================================================
import { Metadata } from "next";

import Posts from "@/components/Posts";

export const metadata: Metadata = {
  title: "Home - CodeStash",
};

export default function Home() {
  return <Posts />;
}



================================================
FILE: frontend/src/app/providers.tsx
================================================
"use client";

import { getQueryClient } from "@/utils/get-query-client";
import { QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import type * as React from "react";

export const queryClient = getQueryClient();

export default function Providers({ children }: { children: React.ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools />
    </QueryClientProvider>
  );
}



================================================
FILE: frontend/src/app/c/page.tsx
================================================
import { redirect } from "next/navigation";

export default function Page() {
  redirect("/communities");
}



================================================
FILE: frontend/src/app/c/[community]/page.tsx
================================================
"use client";

import { CommunityTypes } from "@/app/communities/page";
import CommunityOptionsModal from "@/components/CommunityOptionsModal";
import CommunityPosts from "@/components/CommunityPosts";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import UploadAvatar from "@/components/UploadAvatar";
import UploadCoverImage from "@/components/UploadCoverImage";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { Avatar, Button, Tab, Tabs } from "@heroui/react";
import { useQuery } from "@tanstack/react-query";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useState, use } from "react";
import toast from "react-hot-toast";
import { FaPlus as PlusIcon } from "react-icons/fa";

export type FilterTypes = "Latest" | "Oldest" | "Popular";

const filters: { name: FilterTypes }[] = [
  { name: "Popular" },
  { name: "Latest" },
  { name: "Oldest" },
];

export default function Page(props: { params: Promise<{ community: string }> }) {
  const params = use(props.params);
  const { userData, isLoggedIn, joinCommunity, leaveCommunity } =
    useUserStore();
  const [hasJoinedCommunity, setHasJoinedCommunity] = useState(
    userData?.communitiesJoined.includes(params.community),
  );
  const router = useRouter();
  const { data, isLoading, isError, refetch } = useQuery<CommunityTypes>({
    queryKey: [`c/${params.community}`],
    queryFn: () => {
      // TODO: if community does not exist, show error page.
      return fetcher
        .post("/community/get-community", {
          name: params.community,
        })
        .then((res) => {
          setMembers(res.joinedMembers);
          setDescription(res.description);
          return res;
        });
    },
  });
  const [members, setMembers] = useState(data?.joinedMembers || 0);
  const [description, setDescription] = useState(data?.description || "");

  if (params.community === "all") router.push("/");

  // FIXME: Loading screen here
  if (isLoading) return "Loading...";
  if (isError || !data) return "Error";

  function handleLeaveAndJoin(name: string, action: "join" | "leave") {
    if (!name) return;
    if (!isLoggedIn) {
      toast.error("You need to be logged in to join/leave a community");
      return;
    }

    if (action === "join") {
      joinCommunity(name);
      setHasJoinedCommunity(true);
      setMembers((count) => count + 1);
    } else {
      leaveCommunity(name);
      setHasJoinedCommunity(false);
      setMembers((count) => count - 1);
    }
  }

  return (
    <>
      <section className={cn(cardLayout, "mb-6")}>
        {data.coverImage && (
          <img
            src={data.coverImage}
            alt={`Cover image of c/${data.name}`}
            className="-mb-4 aspect-[4/1] w-full rounded-xl drop-shadow-lg"
          />
        )}
        <Card className="border-t-5 border-primary">
          <CardHeader className="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between sm:gap-0">
            <div className="ml-1 flex gap-4">
              <Avatar
                src={data.avatar}
                className="h-20 w-20"
                name={data.name}
                size="lg"
              />
              <div>
                <h1 className="text-xl font-semibold">c/{data.name}</h1>
                <p className="max-w-96">{description}</p>
              </div>
            </div>
            {hasJoinedCommunity ? (
              <Button
                color="primary"
                radius="full"
                as={Link}
                href={`/create-post?community=${data.name}`}
              >
                <PlusIcon className="" />
                Create Post in c/{data.name}
              </Button>
            ) : (
              <Button
                color="primary"
                variant="flat"
                radius="md"
                onClick={() => handleLeaveAndJoin(data.name, "join")}
              >
                + Join community
              </Button>
            )}
          </CardHeader>
          <CardContent>
            <div className="mb-4 flex flex-col gap-2 sm:flex-row sm:justify-end">
              {hasJoinedCommunity && (
                <Button
                  color="danger"
                  variant="flat"
                  radius="md"
                  size="sm"
                  onClick={() => handleLeaveAndJoin(data.name, "leave")}
                >
                  - Leave community
                </Button>
              )}

              {data.madeBy.username === userData?.username &&
                hasJoinedCommunity && (
                  <>
                    <CommunityOptionsModal
                      community={data}
                      description={description}
                      setDescription={setDescription}
                    />
                    <UploadAvatar
                      buttonText={
                        userData?.avatar ? "Update avatar" : "Upload avatar"
                      }
                      type="community"
                      communityName={data.name}
                      refetch={refetch}
                    />
                    <UploadCoverImage
                      buttonText={
                        data.coverImage
                          ? "Update cover image"
                          : "Upload cover image"
                      }
                      communityName={data.name}
                      refetch={refetch}
                    />
                  </>
                )}
            </div>
            <div className="-mb-2 text-center text-sm">
              <p>
                {members} {members === 1 ? "member" : "members"}
              </p>
              <p>
                community created by{" "}
                <Link
                  href={`/u/${data.madeBy.username}`}
                  className="text-primary underline"
                >
                  u/{data.madeBy.username}
                </Link>
              </p>
            </div>
          </CardContent>
        </Card>
      </section>
      <Tabs
        aria-label="Dynamic tabs"
        items={filters}
        defaultSelectedKey={"Latest"}
        color="primary"
        variant="underlined"
        size="lg"
      >
        {(item) => (
          <Tab key={item.name} title={item.name}>
            <CommunityPosts communityName={data.name} filter={item.name} />
          </Tab>
        )}
      </Tabs>
    </>
  );
}



================================================
FILE: frontend/src/app/communities/page.tsx
================================================
"use client";

import { FaPlus as PlusIcon } from "react-icons/fa";
import CommunityItem from "@/components/CommunityItem";
import CommunitiesSkeleton from "@/components/skeletons/CommunitiesSkeleton";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { Button } from "@heroui/react";
import { useQuery } from "@tanstack/react-query";
import useTitle from "@/hooks/useTitle";
import Link from "next/link";

export type CommunityTypes = {
  madeBy: {
    userId: string;
    username: string;
  };
  _id: string;
  name: string;
  description: string;
  joinedMembers: number;
  avatar: string;
  coverImage: string;
};

export default function Communities() {
  // TODO: add community types
  useTitle("Communities");
  const { data, isLoading, isError } = useQuery<CommunityTypes[]>({
    queryKey: ["communities"],
    queryFn: async () => {
      return await fetcher.get("/community/get-all");
    },
  });
  const { isLoggedIn } = useUserStore();

  if (isError) return "Error";
  if (isLoading) return <CommunitiesSkeleton />;

  return (
    <section className={cn(cardLayout, "flex flex-col gap-4")}>
      <h1 className="text-2xl font-bold text-gray-600">Communities</h1>
      {isLoggedIn && (
        <>
          <Button
            color="primary"
            className="h-14 text-lg"
            variant="flat"
            as={Link}
            href="/create-community"
          >
            <PlusIcon />
            Create your own community
          </Button>
          <p className="text-grey-700 text-center text-sm">Or join one below</p>
        </>
      )}
      {data?.map((community) => (
        <CommunityItem community={community} key={community._id} />
      ))}
    </section>
  );
}



================================================
FILE: frontend/src/app/create-community/page.tsx
================================================
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import { FormEvent, useState } from "react";
import { BiLoaderAlt as Loader } from "react-icons/bi";

import NotLoggedIn from "@/components/NotLoggedIn";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "@/components/ui/use-toast";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { useMutation } from "@tanstack/react-query";
import useTitle from "@/hooks/useTitle";

export default function CreateCommunity() {
  useTitle("Create Community");

  const { isLoggedIn, setUserData } = useUserStore();
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const router = useRouter();
  const { mutate, isPending } = useMutation({
    mutationKey: ["create-community"],
    mutationFn: async () => {
      return await fetcher
        .post("/community/create-community", { name, description })
        .then((res) => {
          setUserData(res.user);

          toast({
            description: `Created c/${name} community successfully`,
          });

          router.push(`/c/${name}`);

          setName("");
          setDescription("");
        })
        .catch((error) => {
          if (error.response.status === 409) {
            toast({
              description: "A community with this name already exists",
            });
          }
        });
    },
  });

  async function createCommunity(e: FormEvent) {
    e.preventDefault();

    if (!name || !description) {
      toast({
        description: "Name and description are required to create a community",
      });
      return;
    }

    mutate();
  }

  if (!isLoggedIn) {
    return (
      <NotLoggedIn
        title="Create Community"
        description="Login or sign up to create communities"
      />
    );
  }

  return (
    <Card className={cn(cardLayout)}>
      <CardHeader>
        <CardTitle className="text-2xl">Create Community</CardTitle>
      </CardHeader>
      <CardContent>
        <form onSubmit={createCommunity}>
          <div className="grid gap-4">
            <div className="grid gap-2">
              <Label htmlFor="name">
                Name of the community{" "}
                <span className="text-xs text-gray-600">(must be unique)</span>
              </Label>
              <Input
                id="name"
                placeholder="react-server-components"
                required
                value={name}
                onChange={(e) => setName(e.target.value)}
              />
            </div>

            <div className="grid gap-2">
              <Label htmlFor="description">Description</Label>
              <Textarea
                placeholder="Explain about your community"
                id="description"
                required
                value={description}
                onChange={(e) => setDescription(e.target.value)}
              />
            </div>
            <Button type="submit" className="w-full" disabled={isPending}>
              {isPending && <Loader className="mr-2 size-4 animate-spin" />}
              Create community
            </Button>
          </div>
          <div className="mt-4 text-center text-sm">
            {/* FIXME: fix this */}
            Don&apos;t have an account?{" "}
            <Link href="/register" className="underline">
              Sign up
            </Link>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}



================================================
FILE: frontend/src/app/create-post/page.tsx
================================================
"use client";

import UploadCodeFromFile from "@/components/buttons/UploadCodeFromFile";
import UploadCodeFromGithub from "@/components/buttons/UploadCodeFromGithub";
import MutationButton from "@/components/MutationButton";
import NotLoggedIn from "@/components/NotLoggedIn";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/components/ui/use-toast";
import useTitle from "@/hooks/useTitle";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { allowedLanguages } from "@/utils/constants";
import { useMutation } from "@tanstack/react-query";
import CodeEditor from "@uiw/react-textarea-code-editor";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { FormEvent, useState } from "react";
import { toast as rhToast } from "react-hot-toast";
import { queryClient } from "../providers";

export default function CreatePost() {
  useTitle("Create Post");

  const searchParams = useSearchParams();
  const [title, setTitle] = useState("");
  const [language, setLanguage] = useState(
    searchParams.get("language") ? searchParams.get("language") : "",
  );
  const [description, setDescription] = useState("");
  const [code, setCode] = useState("");
  const { toast } = useToast();
  const { isLoggedIn, userData } = useUserStore();
  const [community, setCommunity] = useState(searchParams.get("community"));
  const router = useRouter();
  const { mutate, isPending } = useMutation({
    mutationKey: ["create-post"],
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["user-posts"] });
      queryClient.invalidateQueries({ queryKey: ["posts"] });

      setTitle("");
      setCode("");
      setDescription("");

      toast({
        title: "Post Created",
        description: `Your post in c/${community} written in ${language} was created successfully.`,
      });

      router.push(`/post/${data._id}`);
    },
    mutationFn: () => {
      return fetcher.post("/posts/create-post", {
        content: code,
        language,
        description,
        title,
        community,
      });
    },
  });

  if (!community) setCommunity("all");

  function handleSubmit(e: FormEvent) {
    e.preventDefault();

    if (!language) {
      toast({
        title: "Programming language not selected",
        description: "Please select a programming language to create a post",
      });
      return;
    }

    if (code.length > 9_000) {
      rhToast.error("Code is too long. Please keep it under 9,000 characters.");
      return;
    }

    if (!userData?.communitiesJoined.includes(community!)) {
      // FIXME: add better looking toasts
      toast({
        title: "You haven't joined this community yet",
        description: `Cannot create post in c/${community}.`,
      });

      return;
    }

    mutate();
  }

  if (!isLoggedIn) {
    return (
      <NotLoggedIn
        title="Create Post"
        description="Login or sign up to create posts"
      />
    );
  }

  // TODO: better ui for this
  if (!userData?.communitiesJoined.includes(community!))
    return (
      <Card className={cn(cardLayout)}>
        <CardHeader>
          <CardTitle>
            You can&apos;t create a post in c/{community} before joining it
          </CardTitle>
        </CardHeader>
      </Card>
    );

  return (
    <Card className={cn(cardLayout, "mx-auto")}>
      <CardHeader>
        <CardTitle className="text-2xl">Create Post</CardTitle>
        <CardDescription>
          You are creating a post in{" "}
          <Link href={`/c/${community}`} className="underline">
            c/{community}
          </Link>
          {community === "all" && (
            <span className="text-xs"> (default community)</span>
          )}
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit}>
          <div className="grid gap-4">
            <div className="grid gap-2">
              <Label htmlFor="title">Title</Label>
              <Input
                id="title"
                placeholder="React server component"
                required
                value={title}
                onChange={(e) => setTitle(e.target.value)}
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="language">Programming Language</Label>
              <Select
                required
                onValueChange={(lang) => setLanguage(lang)}
                value={language!}
              >
                <SelectTrigger id="language">
                  <SelectValue placeholder="Language" />
                </SelectTrigger>
                <SelectContent>
                  {[...allowedLanguages].map((lang) => (
                    <SelectItem value={lang} key={lang}>
                      {lang}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="grid gap-2">
              {/* TODO: Make this WYSIWYG editor */}
              <Label htmlFor="description">Description</Label>
              <Textarea
                placeholder="How is this code snippet useful?"
                id="description"
                value={description}
                required
                onChange={(e) => setDescription(e.target.value)}
              />
            </div>
            {/* <div> */}
            {/* </div> */}
            <div className="grid gap-2">
              <div className="flex items-end justify-between gap-4">
                <Label htmlFor="content">Code</Label>
                <div className="flex gap-4">
                  <UploadCodeFromGithub setCode={setCode} />
                  <UploadCodeFromFile setCode={setCode} />
                </div>
              </div>
              <CodeEditor
                value={code}
                language={language || "python"}
                placeholder={
                  language ? `Please enter ${language} code` : "Enter code here"
                }
                onChange={(evn) => setCode(evn.target.value)}
                className="rounded-xl"
                required
                data-color-mode="dark"
                padding={15}
                style={{
                  fontFamily:
                    "ui-monospace,SFMono-Regular,SF Mono,Consolas,Liberation Mono,Menlo,monospace",
                }}
              />
            </div>
            <MutationButton type="submit" isPending={isPending}>
              Create post in c/{community}
            </MutationButton>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}



================================================
FILE: frontend/src/app/downvoted/page.tsx
================================================
import DownvotedPosts from "@/components/DownvotedPosts";
import { Metadata } from "next";

export const metadata: Metadata = {
  title: "Downvoted Posts - CodeStash",
};

// have to do this because of https://stackoverflow.com/questions/76404674/type-error-page-has-an-invalid-default-export-type-is-not-valid
export default function DownvotedPostsPage() {
  return <DownvotedPosts />;
}



================================================
FILE: frontend/src/app/languages/page.tsx
================================================
import Link from "next/link";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { cardLayout } from "@/utils/classnames";
import { allowedLanguages } from "@/utils/constants";
import { Metadata } from "next";

export const metadata: Metadata = {
  title: "Popular Languages - CodeStash",
};

// TODO: in this page add a button below for user to make a request to add more programming language
export default function Languages() {
  return (
    <section className={cn(cardLayout)}>
      <h1 className="mb-4 text-2xl font-bold text-gray-600">
        Popular Languages
      </h1>
      <div className="flex flex-wrap gap-8">
        {allowedLanguages.map((lang) => (
          <Link href={`/?language=${lang}`} key={lang}>
            <Card className="flex h-32 w-32 flex-col items-center justify-center">
              <CardHeader>
                <CardTitle>{lang}</CardTitle>
              </CardHeader>
              <CardContent>
                <img
                  src={`https://skillicons.dev/icons?i=${lang}`}
                  alt={lang}
                  className="h-12 w-12"
                />
              </CardContent>
            </Card>
          </Link>
        ))}
      </div>
    </section>
  );
}



================================================
FILE: frontend/src/app/login/page.tsx
================================================
import { Metadata } from "next";

import LoginForm from "@/components/LoginForm";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { cardLayout } from "@/utils/classnames";

export const metadata: Metadata = {
  title: "Login - CodeStash",
};

export default function Login() {
  return (
    <main className={cn(cardLayout, `flex items-center justify-center pt-10`)}>
      <Card className="max-w-sm">
        <CardHeader>
          <CardTitle className="text-2xl">Login</CardTitle>
          <CardDescription>
            Enter your email below to login to your account
          </CardDescription>
        </CardHeader>
        <CardContent>
          <LoginForm />
        </CardContent>
      </Card>
    </main>
  );
}



================================================
FILE: frontend/src/app/post/[postId]/page.tsx
================================================
"use client";

import AiAnswerCard from "@/components/AiAnswerCard";
import BackButton from "@/components/buttons/BackButton";
import CopyCodeButton from "@/components/buttons/CopyCodeButton";
import DeletePostButton from "@/components/buttons/DeletePostButton";
import ExplainThisButton from "@/components/buttons/ExplainThis";
import VSCodeButton from "@/components/buttons/VSCodeButton";
import Comments from "@/components/Comments";
import PostSkeleton from "@/components/skeletons/PostSkeleton";
import { linkButtonStyle } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import { PostTypes } from "@/types/postTypes";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { useAutoAnimate } from "@formkit/auto-animate/react";
import { Button } from "@heroui/react";
import { useQuery } from "@tanstack/react-query";
import CodeEditor from "@uiw/react-textarea-code-editor";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useState, use } from "react";
import {
  BiDownvote as DownvoteIcon,
  BiSolidDownvote as SolidDownvoteIcon,
  BiSolidUpvote as SolidUpvoteIcon,
  BiUpvote as UpvoteIcon,
} from "react-icons/bi";
import { LuPencilLine as EditIcon } from "react-icons/lu";
import {
  MdBookmarkAdd as BookmarkAddIcon,
  MdBookmarkRemove as BookmarkRemoveIcon,
} from "react-icons/md";

export default function Post({ params }: { params: { postId: string } }) {
  const {
    isLoggedIn,
    userData,
    savePost,
    removeSavedPost,
    upvotePost,
    downvotePost,
  } = useUserStore();
  const router = useRouter();
  const [parent] = useAutoAnimate();
  const {
    data: post,
    isError,
    isLoading,
  } = useQuery<PostTypes>({
    queryKey: [params.postId],
    queryFn: async () => {
      return await fetcher
        .post("/posts/get-post", { postId: params.postId })
        .then((res) => {
          setUpvoteCount(res.upvotes - res.downvotes);
          return res;
        });
    },
  });
  const [upvoteCount, setUpvoteCount] = useState(
    post ? post.upvotes - post.downvotes : 0,
  );
  const [aiAnswer, setAiAnswer] = useState<string | undefined>();

  // TODO: Create a custom hook to do this
  function handleInteraction(postId: string, action: "upvote" | "downvote") {
    if (!isLoggedIn) {
      router.push("/login");
      return;
    }

    if (action === "upvote") {
      upvotePost(postId);
      if (userData?.upvotedPosts.includes(postId)) {
        setUpvoteCount((count) => count - 1);
      } else {
        if (userData?.downvotedPosts.includes(postId)) {
          setUpvoteCount((count) => count + 2);
        } else {
          setUpvoteCount((count) => count + 1);
        }
      }
    } else if (action === "downvote") {
      downvotePost(postId);
      if (userData?.downvotedPosts.includes(postId)) {
        setUpvoteCount((count) => count + 1);
      } else {
        if (userData?.upvotedPosts.includes(postId)) {
          setUpvoteCount((count) => count - 2);
        } else {
          setUpvoteCount((count) => count - 1);
        }
      }
    }
  }

  if (isLoading) return <PostSkeleton />;
  if (isError || !post) return "Error";

  return (
    <section className={cn(cardLayout)}>
      <div className="flex items-center justify-between">
        <BackButton />
        {post.madeBy.userId === userData?._id && (
          <div>
            <Link
              className={cn(linkButtonStyle, "hover:text-primary")}
              href={`/update-post?postId=${post._id}`}
            >
              <EditIcon className="mr-1 size-4" />
              Update Post
            </Link>
            <DeletePostButton postId={post._id} />
          </div>
        )}
        <ExplainThisButton postId={post._id} setAiAnswer={setAiAnswer} />
      </div>
      <Card>
        <CardHeader className="flex flex-row items-center gap-4">
          <div className="flex flex-col items-center" ref={parent}>
            {userData?.upvotedPosts.includes(post._id) ? (
              <SolidUpvoteIcon
                className="size-5 cursor-pointer"
                onClick={() => handleInteraction(post._id, "upvote")}
              />
            ) : (
              <UpvoteIcon
                className="size-5 cursor-pointer"
                onClick={() => handleInteraction(post._id, "upvote")}
              />
            )}
            {upvoteCount}
            {userData?.downvotedPosts.includes(post._id) ? (
              <SolidDownvoteIcon
                className="size-5 cursor-pointer"
                onClick={() => handleInteraction(post._id, "downvote")}
              />
            ) : (
              <DownvoteIcon
                className="size-5 cursor-pointer"
                onClick={() => handleInteraction(post._id, "downvote")}
              />
            )}
          </div>
          <div>
            <CardTitle className="text-lg">{post.title}</CardTitle>
            <CardDescription>
              <Link
                href={
                  post.madeBy.username === userData?.username
                    ? "/profile"
                    : `/u/${post.madeBy.username}`
                }
              >
                u/{post.madeBy.username}
              </Link>
            </CardDescription>
          </div>
        </CardHeader>
        <CardContent className="flex flex-col gap-4">
          <p className="whitespace-pre-wrap">{post.description}</p>
          <VSCodeButton
            snippet={post.content}
            fileName={post.title}
            fileType={post.language}
          />
          <CodeEditor
            value={post.content}
            language={post.language}
            className="cursor-text rounded-xl"
            required
            disabled
            data-color-mode="dark"
            padding={15}
            style={{
              fontFamily:
                "ui-monospace,SFMono-Regular,SF Mono,Consolas,Liberation Mono,Menlo,monospace",
            }}
          />
          <div className="flex gap-2">
            {isLoggedIn && (
              <>
                {userData?.savedPosts.includes(post._id) ? (
                  <Button
                    variant="flat"
                    color="danger"
                    radius="full"
                    className="w-full"
                    // className="w-full rounded-[20px] text-lg"
                    onClick={() => removeSavedPost(post._id)}
                  >
                    <BookmarkRemoveIcon className="size-5" />
                    Remove from saved
                  </Button>
                ) : (
                  <Button
                    variant="flat"
                    color="success"
                    radius="full"
                    className="w-full"
                    // className="w-full text-lg"
                    onClick={() => savePost(post._id)}
                  >
                    <BookmarkAddIcon className="size-5" />
                    Save post
                  </Button>
                )}
              </>
            )}
            <CopyCodeButton code={post.content} />
          </div>
        </CardContent>
        <CardFooter className="flex flex-col gap-2">
          <p>
            Posted in{" "}
            <Link href={`/c/${post.community}`} className="underline">
              c/{post.community}
            </Link>{" "}
            community
          </p>

          {/* FIXME: make this a badge, label or chip that a user can click */}
          <p id="ai-explanation">
            Written in{" "}
            <Link href={`/?language=${post.language}`} className="underline">
              {post.language}
            </Link>{" "}
          </p>
        </CardFooter>
      </Card>
      <AiAnswerCard
        aiAnswer={aiAnswer}
        setAiAnswer={setAiAnswer}
        postId={post._id}
      />
      {/* TODO: add a card that displays some stats about the community that this post is posted in */}
      <Comments postId={params.postId} madeBy={post.madeBy.username} />
    </section>
  );
}



================================================
FILE: frontend/src/app/profile/page.tsx
================================================
"use client";

import NotLoggedIn from "@/components/NotLoggedIn";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import { cardLayout } from "@/utils/classnames";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
} from "@/components/ui/card";
import { Avatar, Button } from "@heroui/react";
import { Tabs, Tab } from "@heroui/react";
import UserPosts from "@/components/UserPosts";
import UploadAvatar from "@/components/UploadAvatar";
import Link from "next/link";
import SavedPosts from "@/components/SavedPosts";
import UpvotedPosts from "@/components/UpvotedPosts";
import DownvotedPosts from "@/components/DownvotedPosts";
import useTitle from "@/hooks/useTitle";
import { MdOutlineDriveFileRenameOutline as UpdateUsernameIcon } from "react-icons/md";
import { RiLockPasswordLine as UpdatePasswordIcon } from "react-icons/ri";

// TODO: This page should show the user's personal details, saved posts, etc (i.e. everything that is publically visible + everything that is NOT publically visible)
export default function Profile() {
  useTitle("Profile");
  const { isLoggedIn, userData } = useUserStore();

  if (!isLoggedIn) {
    return (
      <NotLoggedIn
        title="Your Profile"
        description="Login or sign up to view your profile"
      />
    );
  }

  return (
    <section className={cn(cardLayout)}>
      <h1 className="mb-4 text-2xl font-bold text-gray-600">Your Profile</h1>
      <Card className="mx-auto mb-8">
        <CardContent className="flex flex-col gap-4 p-10 sm:flex-row md:gap-10">
          {userData?.avatar ? (
            <Link target="_blank" href={userData?.avatar!}>
              <Avatar
                src={userData?.avatar}
                size="lg"
                className="size-14 sm:size-20 lg:size-32"
              />
            </Link>
          ) : (
            <Avatar
              src={userData?.avatar}
              size="lg"
              className="size-14 sm:size-20 lg:size-32"
            />
          )}
          <div>
            <h2 className="text-grey-900 text-2xl font-medium">
              {userData?.firstName} {userData?.lastName}
            </h2>
            <CardDescription className="mb-2">
              u/{userData?.username}
            </CardDescription>
            {/* TODO: replace these three lines with something better */}
            <h3>Saved Posts: {userData?.savedPosts.length}</h3>
            <h3>Upvoted Posts: {userData?.upvotedPosts.length}</h3>
            <h3>Downvoted Posts: {userData?.downvotedPosts.length}</h3>
          </div>
        </CardContent>
        <CardFooter className="flex flex-col items-start gap-4 px-10 sm:flex-row">
          <UploadAvatar
            buttonText={userData?.avatar ? "Update Avatar" : "Upload Avatar"}
            type="user"
          />
          <Button
            as={Link}
            href="/settings#change-username"
            color="primary"
            radius="md"
            size="sm"
            variant="flat"
          >
            <UpdateUsernameIcon className="size-4" />
            Change Username
          </Button>
          <Button
            as={Link}
            href="/settings#change-password"
            color="primary"
            radius="md"
            size="sm"
            variant="flat"
          >
            <UpdatePasswordIcon className="size-4" />
            Change Password
          </Button>
        </CardFooter>
      </Card>
      <div className="flex w-full flex-col">
        <Tabs
          aria-label="Options"
          size="lg"
          variant="underlined"
          color="primary"
        >
          <Tab key="your-posts" title="Your Posts">
            <UserPosts />
          </Tab>
          <Tab key="saved" title="Saved Posts">
            <SavedPosts hasTitle={false} />
          </Tab>
          <Tab key="upvoted" title="Upvoted Posts">
            <UpvotedPosts hasTitle={false} />
          </Tab>
          <Tab key="downvoted" title="Downvoted Posts">
            <DownvotedPosts hasTitle={false} />
          </Tab>
        </Tabs>
      </div>
    </section>
  );
}



================================================
FILE: frontend/src/app/register/page.tsx
================================================
import { Metadata } from "next";

import RegisterForm from "@/components/RegisterForm";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { cardLayout } from "@/utils/classnames";

export const metadata: Metadata = {
  title: "Sign up - CodeStash",
};

export default function Register() {
  return (
    <main className={cn(cardLayout, "flex items-center justify-center pt-10")}>
      <Card className="max-w-sm">
        <CardHeader>
          <CardTitle className="text-xl">Sign Up</CardTitle>
          <CardDescription>
            Enter your information to create an account
          </CardDescription>
        </CardHeader>
        <CardContent>
          <RegisterForm />
        </CardContent>
      </Card>
    </main>
  );
}



================================================
FILE: frontend/src/app/saved/page.tsx
================================================
import SavedPosts from "@/components/SavedPosts";
import { Metadata } from "next";

export const metadata: Metadata = {
  title: "Saved Posts - CodeStash",
};

export default function SavedPostsPage() {
  return <SavedPosts />;
}



================================================
FILE: frontend/src/app/search/page.tsx
================================================
"use client";

import PostItem from "@/components/PostItem";
import PostsLoading from "@/components/skeletons/PostsLoading";
import { cn } from "@/lib/utils";
import { PostTypes } from "@/types/postTypes";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { Button } from "@heroui/react";
import { useQuery } from "@tanstack/react-query";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { useEffect } from "react";
import { TbError404 as NotFoundIcon } from "react-icons/tb";

export default function SearchPage() {
  const searchParams = useSearchParams();
  const query = searchParams.get("query");
  const {
    data: posts,
    isError,
    isLoading,
    refetch,
  } = useQuery({
    queryKey: ["search"],
    queryFn: () => {
      return fetcher.get("/posts/search", { params: { query } });
    },
    retry: 0,
  });
  const router = useRouter();

  useEffect(() => {
    refetch();
  }, [query, refetch]);

  // TODO: better ui for search page when input empty
  if (!query) return "Search something here...";
  if (isError || !posts) return "Error";
  if (isLoading) return <PostsLoading items={2} />;

  if (posts.length === 0)
    return (
      <section className={cn(cardLayout)}>
        <h1 className="mb-4 text-2xl font-bold text-gray-600">
          Search results for: {query}
        </h1>
        <div className="mt-10 flex flex-col items-center justify-center gap-4">
          <NotFoundIcon className="text-[200px] text-secondary" />
          <p>Currenly there are no posts for: {query}</p>
          <Button
            as={Link}
            href="/create-post"
            color="primary"
            className="drop-shadow-xl"
          >
            Create post
          </Button>
        </div>
      </section>
    );

  return (
    <section className={cn(cardLayout)}>
      <h1 className="mb-4 text-2xl font-bold text-gray-600">
        Search results for: {query}
      </h1>
      <div className="flex flex-col gap-8">
        {posts.map((post: PostTypes) => (
          <PostItem key={post._id} post={post} />
        ))}
      </div>
    </section>
  );
}



================================================
FILE: frontend/src/app/settings/page.tsx
================================================
"use client";

import ChangePassword from "@/components/ChangePassword";
import NotLoggedIn from "@/components/NotLoggedIn";
import SetDownloadPath from "@/components/SetDownloadPath";
import UpdateUsername from "@/components/UpdateUsername";
import useTitle from "@/hooks/useTitle";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import { cardLayout } from "@/utils/classnames";

export default function AccountSettings() {
  useTitle("Account Settings");

  const { isLoggedIn } = useUserStore();

  if (!isLoggedIn) {
    return (
      <NotLoggedIn
        title="Account Settings"
        description="Login or sign up to view your account settings"
      />
    );
  }

  return (
    <section className={cn(cardLayout, "mb-56")}>
      <h1 className="mb-4 text-2xl font-bold text-gray-600">
        Account Settings
      </h1>
      <SetDownloadPath />
      <UpdateUsername />
      <ChangePassword />
    </section>
  );
}



================================================
FILE: frontend/src/app/u/[userName]/page.tsx
================================================
"use client";

import PostsByUsername from "@/components/PostsByUsername";
import { Card, CardContent, CardDescription } from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import { UserTypes } from "@/types/userTypes";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { Avatar } from "@heroui/react";
import { useQuery } from "@tanstack/react-query";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useEffect, use } from "react";

export default function UserProfile(
  props: {
    params: Promise<{ userName: string }>;
  }
) {
  const params = use(props.params);
  const router = useRouter();
  const { userData } = useUserStore();
  const {
    data: user,
    isError,
    error,
    isLoading,
  } = useQuery<UserTypes>({
    queryKey: [params.userName],
    queryFn: async () => {
      return await fetcher.post("/users/get-user-profile", {
        username: params.userName,
      });
    },
  });

  useEffect(() => {
    if (params.userName === userData?.username) {
      router.push("/profile");
    }
  }, []);

  if (isLoading) return "Loading...";
  // TODO: user doesn't exist error
  if (isError || !user) {
    // @ts-expect-error
    if (error?.response?.status === 404) {
      console.log(error);
      // TODO: add a better error ui
      return "User doesn't exist";
    }
    return "Error";
  }

  return (
    <section className={cn(cardLayout)}>
      <h1 className="mb-4 text-2xl font-bold text-gray-600">
        Profile of <span className="underline">u/{user.username}</span>
      </h1>
      <Card className="mx-auto mb-8">
        <CardContent className="flex flex-col gap-10 p-10 sm:flex-row">
          {user?.avatar ? (
            <Link target="_blank" href={user?.avatar!}>
              <Avatar
                src={user?.avatar}
                size="lg"
                className="size-14 sm:size-20 lg:size-32"
              />
            </Link>
          ) : (
            <Avatar
              src={user?.avatar}
              size="lg"
              className="size-14 sm:size-20 lg:size-32"
            />
          )}
          <div>
            <h2 className="text-grey-900 text-2xl font-medium">
              {user.firstName} {user.lastName}
            </h2>
            <CardDescription className="mb-2">
              u/{user.username}
            </CardDescription>
            {/* TODO: replace these three lines with something better */}
            <h3>Upvoted Posts: {user.upvotedPosts.length}</h3>
            <h3>Downvoted Posts: {user.downvotedPosts.length}</h3>
          </div>
        </CardContent>
      </Card>
      {/* <div className="flex w-full flex-col">
        <Tabs
          aria-label="Options"
          size="lg"
          variant="underlined"
          color="primary"
        >
          <Tab key="your-posts" title="Your Posts">
            <UserPosts />
          </Tab>
          <Tab key="upvoted" title="Upvoted Posts">
            <UpvotedPosts hasTitle={false} />
          </Tab>
          <Tab key="downvoted" title="Downvoted Posts">
            <DownvotedPosts hasTitle={false} />
          </Tab>
        </Tabs>
      </div> */}
      <PostsByUsername username={user.username} />
    </section>
  );
}



================================================
FILE: frontend/src/app/update-post/page.tsx
================================================
"use client";

import UploadCodeFromFile from "@/components/buttons/UploadCodeFromFile";
import UploadCodeFromGithub from "@/components/buttons/UploadCodeFromGithub";
import NotLoggedIn from "@/components/NotLoggedIn";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/components/ui/use-toast";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import { PostTypes } from "@/types/postTypes";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { allowedLanguages } from "@/utils/constants";
import { Button } from "@heroui/react";
import { useMutation, useQuery } from "@tanstack/react-query";
import CodeEditor from "@uiw/react-textarea-code-editor";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { FormEvent, useState } from "react";
import { toast as rhToast } from "react-hot-toast";

export default function UpdatePost() {
  const searchParams = useSearchParams();
  const postId = searchParams.get("postId");
  const { toast } = useToast();
  const { isLoggedIn } = useUserStore();
  const router = useRouter();
  const {
    data: post,
    isError,
    isLoading,
  } = useQuery<PostTypes>({
    queryKey: ["get-post-to-update", postId],
    queryFn: () => {
      return fetcher.post("/posts/get-post", { postId }).then((res) => {
        setTitle(res.title);
        setDescription(res.description);
        setCode(res.content);
        setLanguage(res.language);
        return res;
      });
    },
  });
  const { mutate, isPending } = useMutation({
    mutationKey: ["update-post", postId],
    mutationFn: async () => {
      return await fetcher
        .patch("/posts/update-post", {
          postId: post?._id,
          content: code,
          language,
          description,
          title,
        })
        .then((res) => {
          toast({
            title: "Post Updated",
            description: `You post in c/${post?.community} has been updated successfully`,
          });

          router.push(`/post/${post?._id}`);
        });
    },
  });
  const [title, setTitle] = useState(post?.title || "");
  const [language, setLanguage] = useState(post?.language || "");
  const [description, setDescription] = useState(post?.description || "");
  const [code, setCode] = useState(post?.content || "");

  if (!postId) {
    router.push("/create-post");
  }

  function handleSubmit(e: FormEvent) {
    e.preventDefault();

    if (!language) {
      toast({
        title: "Programming language not selected",
        description: "Please select a programming language to update this post",
      });
      return;
    }

    if (code.length > 9_000) {
      rhToast.error("Code is too long. Please keep it under 9,000 characters.");
      return;
    }

    if (
      language === post?.language &&
      code === post?.content &&
      title === post?.title &&
      description === post?.description
    ) {
      toast({
        description: "You haven't updated anything yet",
      });
      return;
    }

    mutate();
  }

  if (!isLoggedIn) {
    return (
      <NotLoggedIn
        title="Update Post"
        description="Login or sign up to update posts"
      />
    );
  }

  // TODO: add better looking error here
  if (isError) return "Error";
  // TODO: add loading skeletons
  if (isLoading) return "Loading...";

  return (
    <Card className={cn(cardLayout, "mx-auto")}>
      <CardHeader>
        <CardTitle className="text-2xl">Update Post</CardTitle>
        <CardDescription>
          You are updating a post in{" "}
          <Link href={`/c/${post?.community}`} className="underline">
            c/{post?.community}
          </Link>
          {post?.community === "all" && (
            <span className="text-xs"> (default community)</span>
          )}
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit}>
          <div className="grid gap-4">
            <div className="grid gap-2">
              <Label htmlFor="title">Title</Label>
              <Input
                id="title"
                placeholder="React server component"
                required
                value={title}
                onChange={(e) => setTitle(e.target.value)}
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="language">Programming Language</Label>
              <Select
                required
                onValueChange={(lang) => setLanguage(lang)}
                value={language!}
              >
                <SelectTrigger id="language">
                  <SelectValue placeholder="Language" />
                </SelectTrigger>
                <SelectContent>
                  {[...allowedLanguages].map((lang) => (
                    <SelectItem value={lang} key={lang}>
                      {lang}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="grid gap-2">
              {/* TODO: Make this WYSIWYG editor */}
              <Label htmlFor="description">Description</Label>
              <Textarea
                placeholder="How is this code snippet useful?"
                id="description"
                value={description}
                required
                onChange={(e) => setDescription(e.target.value)}
              />
            </div>
            <div className="grid gap-2">
              <div className="flex items-end justify-between gap-4">
                <Label htmlFor="content">Code</Label>
                <div className="flex gap-4">
                  <UploadCodeFromGithub setCode={setCode} />
                  <UploadCodeFromFile setCode={setCode} />
                </div>
              </div>
              <CodeEditor
                value={code}
                language={language || "python"}
                placeholder={
                  language ? `Please enter ${language} code` : "Enter code here"
                }
                onChange={(evn) => setCode(evn.target.value)}
                className="rounded-xl"
                required
                data-color-mode="dark"
                padding={15}
                style={{
                  fontFamily:
                    "ui-monospace,SFMono-Regular,SF Mono,Consolas,Liberation Mono,Menlo,monospace",
                }}
              />
            </div>
            <Button
              type="submit"
              className="w-full"
              color="primary"
              isLoading={isPending}
            >
              Update post
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}



================================================
FILE: frontend/src/app/upvoted/page.tsx
================================================
import UpvotedPosts from "@/components/UpvotedPosts";
import { Metadata } from "next";

export const metadata: Metadata = {
  title: "Upvoted Posts - CodeStash",
};

export default function UpvotedPostsPage() {
  return <UpvotedPosts />;
}



================================================
FILE: frontend/src/components/AiAnswerCard.tsx
================================================
import { useUserStore } from "@/store/userStore";
import { axiosInstance } from "@/utils/axios";
import { infoToast } from "@/utils/constants";
import formbricks from "@formbricks/js";
import MarkdownPreview from "@uiw/react-markdown-preview";
import { useRouter } from "next/navigation";
import { useState } from "react";
import toast from "react-hot-toast";
import { BsStars as StarsIcon } from "react-icons/bs";
import MutationButton from "./MutationButton";
import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from "./ui/card";

export default function AiAnswerCard({
  aiAnswer,
  setAiAnswer,
  postId,
}: {
  postId: string;
  aiAnswer?: string;
  setAiAnswer: React.Dispatch<React.SetStateAction<string | undefined>>;
}) {
  const { isLoggedIn } = useUserStore();
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);

  function getAiAnswer() {
    if (!isLoggedIn) {
      infoToast(
        "You must be logged in to use AI features. Login as a demo user to test this feature.",
      );
      return;
    }

    setIsLoading(true);

    const aiAnswerPromise = axiosInstance
      .get("/ai/explain", { params: { postId } })
      .then((res) => {
        setAiAnswer(res.data.data.aiAnswer);
        setIsLoading(false);
        formbricks.track("ai_answer");
        router.push(`#ai-explanation`);
      });

    toast.promise(aiAnswerPromise, {
      loading: "Generating AI Explanation...",
      success: "Generated AI Explanation",
      error: "Our AI is currently under heavy load. Please try again later.",
    });
  }

  return (
    <Card className="mt-8">
      <CardHeader className="flex flex-col text-center">
        <CardTitle className="text-xl">âœ¨ AI Explanation âœ¨</CardTitle>
      </CardHeader>
      <CardContent className="max-w-[700px]" data-color-mode="light">
        {aiAnswer ? (
          <MarkdownPreview source={aiAnswer} />
        ) : (
          <div className="flex w-full items-center justify-center">
            <MutationButton
              onClick={getAiAnswer}
              isPending={isLoading}
              id="ai-button"
            >
              {isLoading ? "Getting" : "Get"} AI Explanation
              <StarsIcon className="size-5" />
            </MutationButton>
          </div>
        )}
      </CardContent>
      {aiAnswer && (
        <CardFooter className="flex justify-center text-sm font-semibold">
          Note that AI models are not perfect and may make mistakes.
        </CardFooter>
      )}
    </Card>
  );
}



================================================
FILE: frontend/src/components/AvatarDropdown.tsx
================================================
import { useUserStore } from "@/store/userStore";
import {
  Dropdown,
  DropdownTrigger,
  DropdownMenu,
  DropdownItem,
  User,
} from "@heroui/react";
import Link from "next/link";

export default function AvatarDropdown() {
  const { userData, logoutUser, showProfileCard, setShowProfileCard } =
    useUserStore();

  function switchProfileCardStatus() {
    setShowProfileCard(!showProfileCard);
  }

  return (
    <Dropdown>
      <DropdownTrigger>
        <User
          as="button"
          avatarProps={{
            isBordered: true,
            src: userData?.avatar,
          }}
          className="mr-10 transition-transform"
          description={`@${userData?.username}`}
          name={`${userData?.firstName} ${userData?.lastName}`}
        />
      </DropdownTrigger>
      <DropdownMenu aria-label="User Actions" variant="flat">
        <DropdownItem
          key="profile"
          className="h-14 gap-2"
          as={Link}
          href="/profile"
        >
          <p className="font-bold">Signed in as</p>
          <p className="font-bold">@{userData?.username}</p>
        </DropdownItem>
        <DropdownItem key="settings" as={Link} href="/settings">
          My Settings
        </DropdownItem>
        <DropdownItem key="saved" as={Link} href="/saved">
          Saved Posts
        </DropdownItem>
        <DropdownItem key="profile-card" onClick={switchProfileCardStatus}>
          {showProfileCard ? "Hide Profile Card" : "Show Profile Card"}
        </DropdownItem>
        {/* <DropdownItem key="configurations">Configurations</DropdownItem> */}
        {/* <DropdownItem key="help_and_feedback">Help & Feedback</DropdownItem> */}
        <DropdownItem key="logout" color="danger" onClick={logoutUser}>
          Log Out
        </DropdownItem>
      </DropdownMenu>
    </Dropdown>
  );
}



================================================
FILE: frontend/src/components/ChangePassword.tsx
================================================
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { BiLoaderAlt as Loader } from "react-icons/bi";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import fetcher from "@/utils/axios";
import { FormEvent, useState } from "react";
import toast from "react-hot-toast";
import { useMutation } from "@tanstack/react-query";
import { AxiosError, AxiosPromise } from "axios";

export default function ChangePassword() {
  const [oldPassword, setOldPassword] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const { mutateAsync, isPending, error } = useMutation<any, AxiosError>({
    mutationKey: ["update-password"],
    mutationFn: () => {
      return fetcher
        .patch("/users/update-password", {
          newPassword,
          oldPassword,
        })
        .then(() => {
          setOldPassword("");
          setNewPassword("");
        });
    },
  });

  async function updatePassword(e: FormEvent) {
    e.preventDefault();
    if (oldPassword === newPassword) {
      // FIXME: add "info" toast like in spendsync
      toast.error("New password can't be the same as the current password");
      return;
    }
    const updatePasswordPromise = mutateAsync();

    toast.promise(updatePasswordPromise, {
      loading: "Changing current password",
      success: "Changed password successfully",
      error:
        error?.response?.status === 401
          ? "Invalid current password"
          : "Failed to change current password",
    });
  }

  return (
    <Card className="mx-auto" id="change-password">
      <CardHeader>
        <CardTitle className="text-xl">Change Password</CardTitle>
        <CardDescription>
          Enter your old password and create a new password to update.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={updatePassword} className="grid max-w-[400px] gap-4">
          <div>
            <Label htmlFor="old-password">Current Password</Label>
            <Input
              id="old-password"
              autoComplete="current-password"
              required
              value={oldPassword}
              onChange={(e) => setOldPassword(e.target.value)}
            />
          </div>
          <div>
            <Label htmlFor="new-password">New Password</Label>
            <Input
              id="new-password"
              autoComplete="new-password"
              required
              value={newPassword}
              onChange={(e) => setNewPassword(e.target.value)}
            />
          </div>
          <Button type="submit" className="w-40" disabled={isPending}>
            {isPending && <Loader className="mr-2 size-4 animate-spin" />}
            Update
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}



================================================
FILE: frontend/src/components/CommentItem.tsx
================================================
import Link from "next/link";
import { useRouter } from "next/navigation";
import React, { FormEvent, useState } from "react";
import {
  BiDownvote as DownvoteIcon,
  BiLoaderAlt as Loader,
  BiSolidDownvote as SolidDownvoteIcon,
  BiSolidUpvote as SolidUpvoteIcon,
  BiUpvote as UpvoteIcon,
} from "react-icons/bi";
import { LuPencilLine as EditIcon } from "react-icons/lu";
import { MdDelete as DeleteIcon } from "react-icons/md";
import {
  Modal,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalFooter,
  useDisclosure,
  Button,
} from "@heroui/react";
import { useUserStore } from "@/store/userStore";
import { Comment } from "@/types/commentTypes";
import fetcher from "@/utils/axios";
import { Textarea } from "@heroui/react";
import { useMutation } from "@tanstack/react-query";
import { Badge } from "./ui/badge";
import { Button as ShadButton } from "./ui/button";
// import { toast } from "./ui/use-toast";
import toast from "react-hot-toast";
import { useAutoAnimate } from "@formkit/auto-animate/react";
import MutationButton from "./MutationButton";
import { infoToast } from "@/utils/constants";

type CommentItemPropTypes = {
  comment: Comment;
  madeBy: string;
  refetch: () => void;
};

function CommentItem({ comment, madeBy, refetch }: CommentItemPropTypes) {
  const { upvoteComment, downvoteComment, isLoggedIn, userData } =
    useUserStore();
  const [upvoteCount, setUpvoteCount] = useState(
    comment.upvotes - comment.downvotes,
  );
  const [updatedContent, setUpdatedContent] = useState(comment.content);
  const { isOpen, onOpen, onOpenChange, onClose } = useDisclosure();
  const [isUpdating, setIsUpdating] = useState(false);
  const router = useRouter();
  const [parent] = useAutoAnimate();

  const { mutate, isPending } = useMutation({
    mutationKey: [`comment - ${comment._id}`],
    mutationFn: async () => {
      const updateCommentPromise = fetcher
        .patch("/comments/update-comment", {
          commentId: comment._id,
          content: updatedContent,
        })
        .then(() => {
          setIsUpdating(false);
          refetch();
        });

      toast.promise(updateCommentPromise, {
        loading: "Updating comment...",
        success: "Comment updated successfully",
        error: "Failed to update comment",
      });

      return updateCommentPromise;
    },
  });

  function handleInteraction(action: "upvote" | "downvote") {
    const commentId = comment._id;

    if (!isLoggedIn) {
      router.push("/login");
      return;
    }

    if (action === "upvote") {
      upvoteComment(commentId);
      if (userData?.upvotedComments.includes(commentId)) {
        setUpvoteCount((count) => count - 1);
      } else {
        if (userData?.downvotedComments.includes(commentId)) {
          setUpvoteCount((count) => count + 2);
        } else {
          setUpvoteCount((count) => count + 1);
        }
      }
    } else if (action === "downvote") {
      downvoteComment(commentId);
      if (userData?.downvotedComments.includes(commentId)) {
        setUpvoteCount((count) => count + 1);
      } else {
        if (userData?.upvotedComments.includes(commentId)) {
          setUpvoteCount((count) => count - 2);
        } else {
          setUpvoteCount((count) => count - 1);
        }
      }
    }

    refetch();
  }

  function updateComment(e: FormEvent) {
    e.preventDefault();

    if (!updatedContent) {
      infoToast("Comment can't be empty");
      return;
    }

    if (updatedContent === comment.content) {
      infoToast("You haven't made any changes");
      return;
    }

    mutate();
  }

  function deleteComment() {
    const deleteCommentPromise = fetcher
      .post("/comments/delete-comment", { commentId: comment._id })
      .then(() => {
        refetch();
      });

    toast.promise(deleteCommentPromise, {
      loading: "Deleting comment...",
      success: "Comment deleted successfully",
      error: "Failed to delete comment",
    });

    onClose();
  }

  return (
    <li className="flex gap-2 rounded-xl bg-primary-50 p-2">
      <div className="flex flex-col items-center" ref={parent}>
        {userData?.upvotedComments.includes(comment._id) ? (
          <SolidUpvoteIcon
            className="size-5 cursor-pointer"
            onClick={() => handleInteraction("upvote")}
          />
        ) : (
          <UpvoteIcon
            className="size-5 cursor-pointer"
            onClick={() => handleInteraction("upvote")}
          />
        )}
        {upvoteCount}
        {userData?.downvotedComments.includes(comment._id) ? (
          <SolidDownvoteIcon
            className="size-5 cursor-pointer"
            onClick={() => handleInteraction("downvote")}
          />
        ) : (
          <DownvoteIcon
            className="size-5 cursor-pointer"
            onClick={() => handleInteraction("downvote")}
          />
        )}
      </div>
      <div className="flex w-full flex-col">
        <div className="flex w-full justify-between">
          <Link
            href={`/u/${comment.madeBy.username}`}
            className="text-grey-700 text-xs"
          >
            u/{comment.madeBy.username}
            {comment.madeBy.username === madeBy && (
              <Badge className="ml-2 text-xs font-normal">OP</Badge>
            )}
          </Link>

          {comment.madeBy.userId === userData?._id && !isUpdating && (
            <div className="flex items-center gap-2 text-xs">
              <button onClick={() => setIsUpdating(true)}>
                <Badge
                  className="font-normal hover:cursor-pointer"
                  variant="default"
                >
                  Update
                </Badge>
              </button>

              <button onClick={onOpen}>
                <DeleteIcon className="size-5 hover:cursor-pointer hover:text-red-500" />
              </button>
              <Modal
                isOpen={isOpen}
                onOpenChange={onOpenChange}
                backdrop="blur"
              >
                <ModalContent>
                  {(onClose) => (
                    <>
                      <ModalHeader className="flex flex-col gap-1">
                        Are you sure about deleting this comment?
                      </ModalHeader>
                      <ModalBody>
                        <p>This will permanently delete your comment.</p>
                      </ModalBody>
                      <ModalFooter>
                        <Button
                          color="danger"
                          variant="light"
                          onPress={onClose}
                        >
                          Close
                        </Button>
                        <Button color="primary" onClick={deleteComment}>
                          Delete Comment
                        </Button>
                      </ModalFooter>
                    </>
                  )}
                </ModalContent>
              </Modal>
            </div>
          )}
        </div>
        {isUpdating ? (
          <form onSubmit={updateComment}>
            <Textarea
              variant="bordered"
              color="primary"
              className="my-2"
              required
              value={updatedContent}
              onChange={(e) => setUpdatedContent(e.target.value)}
            />
            <div className="flex gap-2">
              <MutationButton
                isPending={isPending}
                size="sm"
                radius="lg"
                type="submit"
              >
                {isPending ? "Saving" : "Save"} changes
              </MutationButton>
              {!isPending && (
                <ShadButton
                  size="sm"
                  variant="outline"
                  type="button"
                  onClick={() => {
                    setIsUpdating(false);
                    setUpdatedContent(comment.content);
                  }}
                >
                  Cancel
                </ShadButton>
              )}
            </div>
          </form>
        ) : (
          <p className="whitespace-pre-wrap">{updatedContent}</p>
        )}
        {comment.isEdited && (
          <span className="mr-1 flex items-center gap-1 self-end text-xs text-slate-500">
            edited
            <EditIcon />
          </span>
        )}
      </div>
    </li>
  );
}

export default CommentItem;



================================================
FILE: frontend/src/components/Comments.tsx
================================================
"use client";

import { useRouter } from "next/navigation";
import { FormEvent, useState } from "react";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { useUserStore } from "@/store/userStore";
import { Comment } from "@/types/commentTypes";
import fetcher from "@/utils/axios";
import { Button, Textarea } from "@heroui/react";
import { useMutation, useQuery } from "@tanstack/react-query";

import { useAutoAnimate } from "@formkit/auto-animate/react";
import CommentItem from "./CommentItem";
import CommentsSkeleton from "./skeletons/CommentsSkeleton";

type CommentProps = {
  postId: string;
  madeBy: string;
};

export default function Comments({ postId, madeBy }: CommentProps) {
  const [comment, setComment] = useState("");
  const { isLoggedIn } = useUserStore();
  const router = useRouter();
  const [parent] = useAutoAnimate();
  const { data, isError, isLoading, refetch, isRefetchError, isRefetching } =
    useQuery<Comment[]>({
      queryKey: [`${postId}/comments`],
      queryFn: async () => {
        return await fetcher.post("/comments/get-comments", { postId });
      },
      refetchOnMount: "always",
    });
  const { mutateAsync, isPending } = useMutation({
    mutationKey: [`${postId}/comments`],
    mutationFn: async () => {
      return await fetcher.put("/comments/create-comment", {
        postId,
        content: comment,
      });
    },
  });

  async function addComment(e: FormEvent) {
    e.preventDefault();
    if (!comment) return;

    await mutateAsync();
    await refetch();
    setComment("");
  }

  if (isError || isRefetchError) return "Error";
  if (isLoading) return <CommentsSkeleton />;

  return (
    <Card className="my-6">
      <CardHeader className="">
        <CardTitle>
          {data?.length === 1
            ? `${data.length} Comment`
            : `${data?.length} Comments`}
        </CardTitle>
        {isLoggedIn ? (
          <form onSubmit={addComment}>
            <Textarea
              variant="underlined"
              required
              color="primary"
              value={comment}
              onChange={(e) => setComment(e.target.value)}
              placeholder="Add a comment"
              className={`col-span-12 mb-3 md:col-span-6 ${!comment && "h-10"}`}
            />
            {comment && (
              <Button
                color="primary"
                type="submit"
                isLoading={isRefetching || isPending}
              >
                Add comment
              </Button>
            )}
          </form>
        ) : (
          <div className="flex flex-col gap-2">
            <p>Login to post comments</p>
            <Button
              variant="flat"
              radius="full"
              color="primary"
              className="w-full max-w-80"
              onClick={() => {
                router.push("/login");
              }}
            >
              Login
            </Button>
          </div>
        )}
      </CardHeader>
      <CardContent>
        {data?.length === 0 ? (
          // TODO: add better ui for no comments yet.
          (<p>No comments yet</p>)
        ) : (
          <ul className="flex flex-col gap-2" ref={parent}>
            {/* TODO: show "adding comment..." when user adds a new comment */}
            {data?.map((comment) => (
              <CommentItem
                madeBy={madeBy}
                comment={comment}
                refetch={refetch}
                key={comment._id}
              />
            ))}
          </ul>
        )}
      </CardContent>
    </Card>
  );
}



================================================
FILE: frontend/src/components/CommunityItem.tsx
================================================
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useState } from "react";

import { CommunityTypes } from "@/app/communities/page";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { toast } from "@/components/ui/use-toast";
import { useUserStore } from "@/store/userStore";
import { Button } from "@heroui/react";

export default function CommunityItem({
  community,
}: {
  community: CommunityTypes;
}) {
  const { userData, isLoggedIn, joinCommunity, leaveCommunity } =
    useUserStore();
  const [hasJoinedCommunity, setHasJoinedCommunity] = useState(
    userData?.communitiesJoined.includes(community.name),
  );
  const [members, setMembers] = useState(community.joinedMembers);
  const router = useRouter();

  function handleLeaveAndJoin(name: string, action: "join" | "leave") {
    if (!name) return;
    if (!isLoggedIn) {
      toast({
        description: "You need to be logged in to join/leave a community",
      });
      return;
    }

    if (action === "join") {
      joinCommunity(name);
      setHasJoinedCommunity(true);
      setMembers((count) => count + 1);
    } else {
      leaveCommunity(name);
      setHasJoinedCommunity(false);
      setMembers((count) => count - 1);
    }
  }

  return (
    <Card className="mb-4">
      <CardHeader className="flex flex-row items-center justify-between gap-4">
        <Link href={`c/${community.name}`}>
          <CardTitle className="mb-2 text-lg">c/{community.name}</CardTitle>
          <CardDescription>
            {community.description.length > 200
              ? community.description.slice(0, 200) + "..."
              : community.description}
          </CardDescription>
        </Link>
        <div className="flex flex-col items-center">
          <p className="text-sm">{members} members</p>
          {hasJoinedCommunity ? (
            <Button
              color="danger"
              variant="flat"
              radius="md"
              onClick={() => handleLeaveAndJoin(community.name, "leave")}
            >
              - Leave community
            </Button>
          ) : (
            <Button
              color="primary"
              variant="flat"
              radius="md"
              onClick={() => handleLeaveAndJoin(community.name, "join")}
            >
              + Join community
            </Button>
          )}
        </div>
      </CardHeader>
      <CardContent>
        {/* TODO: add community cover image and avatar here */}
      </CardContent>
      <CardFooter className="flex flex-col gap-2">
        <CardDescription>
          Community created by:{" "}
          <Link href={`u/${community.madeBy.username}`} className="underline">
            u/{community.madeBy.username}
          </Link>
        </CardDescription>
        <Button
          className="w-full"
          color="primary"
          as={Link}
          href={`/c/${community.name}`}
        >
          View Community
        </Button>
      </CardFooter>
    </Card>
  );
}



================================================
FILE: frontend/src/components/CommunityOptionsModal.tsx
================================================
import { CommunityTypes } from "@/app/communities/page";
import {
  Modal,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalFooter,
  Button,
  useDisclosure,
  Textarea,
  Input,
} from "@heroui/react";
import { FormEvent, useState } from "react";
import { FaGears as AccountOptionsIcon } from "react-icons/fa6";
import { Label } from "./ui/label";
import toast from "react-hot-toast";
import fetcher from "@/utils/axios";

// TODO: add delete community option here in this modal
export default function CommunityOptionsModal({
  community,
  description,
  setDescription,
}: {
  community: CommunityTypes;
  description: any;
  setDescription: any;
}) {
  const { isOpen, onOpen, onOpenChange } = useDisclosure();

  function updateDescription(e: FormEvent) {
    e.preventDefault();

    // FIXME: This doesn't work now
    if (!description) {
      toast.error("Description can't be empty");
      return;
    }

    const updateDescriptionPromise = fetcher.put("/community/update-info", {
      description,
      communityName: community.name,
    });

    toast.promise(updateDescriptionPromise, {
      loading: "Updating description...",
      success: "Updated description successfully",
      error: "Error updating description",
    });
  }

  return (
    <>
      <Button
        color="primary"
        variant="flat"
        radius="md"
        onPress={onOpen}
        size="sm"
      >
        <AccountOptionsIcon />
        Options
      </Button>
      <Modal isOpen={isOpen} onOpenChange={onOpenChange}>
        <ModalContent>
          {(onClose) => (
            <>
              <ModalHeader className="flex flex-col gap-1">
                Community Options
              </ModalHeader>
              <form onSubmit={updateDescription}>
                <ModalBody>
                  <Label htmlFor="description">Description</Label>
                  <Textarea
                    variant="bordered"
                    color="primary"
                    id="description"
                    required
                    value={description}
                    onChange={(e) => setDescription(e.target.value)}
                  />
                  {/* <div>
                  <Button color="primary" variant="flat">
                    Upload community avatar
                  </Button>
                  <Button color="primary" variant="flat">
                    Upload cover image
                  </Button>
                  <Input type="file" />
                </div> */}
                </ModalBody>
                <ModalFooter>
                  <Button
                    color="primary"
                    variant="light"
                    onPress={onClose}
                    type="button"
                  >
                    Close
                  </Button>
                  <Button color="primary" onPress={onClose} type="submit">
                    Save changes
                  </Button>
                </ModalFooter>
              </form>
            </>
          )}
        </ModalContent>
      </Modal>
    </>
  );
}



================================================
FILE: frontend/src/components/CommunityPosts.tsx
================================================
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import PostsLoading from "@/components/skeletons/PostsLoading";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { useUserStore } from "@/store/userStore";
import { PostTypes } from "@/types/postTypes";
import fetcher from "@/utils/axios";
import { Button } from "@heroui/react";
import { useQuery } from "@tanstack/react-query";
import { cn } from "@/lib/utils";
import { cardLayout } from "@/utils/classnames";
import { FilterTypes } from "@/app/c/[community]/page";

export default function CommunityPosts({
  communityName,
  filter,
}: {
  communityName: string;
  filter: FilterTypes;
}) {
  const { userData } = useUserStore();
  const { data, isError, isLoading, isRefetching } = useQuery<PostTypes[]>({
    queryKey: [`c/${communityName}/posts - ${filter}`],
    queryFn: async () => {
      return await fetcher.post("/posts/get-posts-by-community", {
        community: communityName,
        filter,
      });
    },
  });

  const router = useRouter();

  if (isError) return "Error";
  if (isLoading || isRefetching)
    return <PostsLoading items={userData?.upvotedPosts.length || 4} />;

  if (data?.length === 0) {
    return (
      <Card
        className={cn(
          cardLayout,
          "mt-4 flex flex-col items-center justify-center",
        )}
      >
        {/* TODO: add an icon/svg here for no saved/downvoted/upvoted posts */}
        <CardHeader>
          <p className="">
            This community does not have any posts yet, <br /> be the first one
            to create a post in c/{communityName}!
          </p>
        </CardHeader>
        <CardContent>
          <Button
            color="primary"
            as={Link}
            href={`/create-post?community=${communityName}`}
          >
            create post in c/{communityName}
          </Button>
        </CardContent>
      </Card>
    );
  }

  return (
    <section className={cn(cardLayout, "mb-6 mt-2")}>
      <div className="flex flex-col gap-8">
        {data?.map((post) => (
          <Card key={post._id}>
            <CardHeader className="flex flex-row items-center gap-4">
              <div>
                <CardTitle className="text-lg">
                  <Link href={`/post/${post._id}`}>{post.title}</Link>
                </CardTitle>
                <CardDescription>
                  <Link href={`/u/${post.madeBy.username}`}>
                    u/{post.madeBy.username}
                  </Link>
                </CardDescription>
              </div>
            </CardHeader>
            <CardContent>
              <p>{post.description}</p>
            </CardContent>
            <CardFooter className="flex flex-col gap-2">
              <p>
                Posted in{" "}
                <Link href={`/c/${post.community}`} className="underline">
                  c/{post.community}
                </Link>{" "}
                community
              </p>
              <Button
                variant="solid"
                className="w-full rounded-[20px] bg-primary text-white"
                as={Link}
                href={`/post/${post._id}`}
              >
                Show code
              </Button>
            </CardFooter>
          </Card>
        ))}
      </div>
    </section>
  );
}



================================================
FILE: frontend/src/components/Dashboard.tsx
================================================
"use client";

import { useUserStore } from "@/store/userStore";
import { useAutoAnimate } from "@formkit/auto-animate/react";
import { useEffect, useState } from "react";
import Navbar from "./NavBar";
import ProfileCard from "./ProfileCard";
import SideBar from "./SideBar";
import FullPagePreLoader from "./animations/FullPagePreLoader";

export default function Dashboard({ children }: { children: React.ReactNode }) {
  const { getCurrentUser, isLoggedIn, showProfileCard } = useUserStore();
  const [parent] = useAutoAnimate();
  const [loading, setLoading] = useState(true);

  // TODO: add Loading user data... screen like monkeytype
  // FIXME: only run this if accessToken and refreshToken exist
  useEffect(() => {
    getCurrentUser().finally(() => setLoading(false));
  }, [getCurrentUser]);

  if (loading) return <FullPagePreLoader />;

  return (
    <div className="mx-auto max-w-[1400px]">
      <Navbar />
      <div className="flex" ref={parent}>
        <SideBar />
        {children}
        {isLoggedIn && showProfileCard && <ProfileCard />}
      </div>
    </div>
  );
}



================================================
FILE: frontend/src/components/DownvotedPosts.tsx
================================================
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";

import NotLoggedIn from "@/components/NotLoggedIn";
import PostsNotFound from "@/components/PostsNotFound";
import PostsLoading from "@/components/skeletons/PostsLoading";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import { PostTypes } from "@/types/postTypes";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { Button } from "@heroui/react";
import { useQuery } from "@tanstack/react-query";

export default function DownvotedPosts({ hasTitle = true }) {
  const { isLoggedIn, userData } = useUserStore();
  const { data, isError, isLoading } = useQuery<PostTypes[]>({
    queryKey: ["downvoted-posts"],
    queryFn: async () => {
      if (userData?.downvotedPosts.length === 0) {
        return [];
      }
      return await fetcher.get("/posts/get-downvoted");
    },
  });

  const router = useRouter();

  if (!isLoggedIn) {
    return (
      <NotLoggedIn
        title="Downvoted Posts"
        description="Login or sign up to view your downvoted posts"
      />
    );
  }
  if (isError) return "Error";
  if (isLoading)
    return <PostsLoading items={userData?.downvotedPosts.length || 2} />;

  if (data?.length === 0) {
    return <PostsNotFound description="You haven't downvoted any posts yet" />;
  }

  return (
    <section className={cn(hasTitle ? cardLayout : "")}>
      {hasTitle && (
        <h1 className="mb-4 text-2xl font-bold text-gray-600">
          Downvoted Posts
        </h1>
      )}
      <div className="flex flex-col gap-8">
        {data?.map((post) => (
          <Card key={post._id}>
            <CardHeader className="flex flex-row items-center gap-4">
              <div>
                <CardTitle className="text-lg">
                  <Link href={`/post/${post._id}`}>{post.title}</Link>
                </CardTitle>
                <CardDescription>
                  <Link href={`/u/${post.madeBy.username}`}>
                    u/{post.madeBy.username}
                  </Link>
                </CardDescription>
              </div>
            </CardHeader>
            <CardContent>
              <p>{post.description}</p>
            </CardContent>
            <CardFooter className="flex flex-col gap-2">
              <p>
                Posted in{" "}
                <Link href={`/c/${post.community}`} className="underline">
                  c/{post.community}
                </Link>{" "}
                community
              </p>
              <Button
                variant="solid"
                className="w-full rounded-[20px] bg-primary text-white"
                as={Link}
                href={`/post/${post._id}`}
              >
                Show code
              </Button>
              {/* TODO: Maybe add a remove from downvotes button here? */}
              {/* <Button
              variant="flat"
              color="primary"
              className="w-full rounded-[20px]"
              // onClick={async () => {
              //   await removeSavedPost(post._id);
              //   refetch();
              // }}
            >
              Remove from saved
            </Button> */}
            </CardFooter>
          </Card>
        ))}
      </div>
    </section>
  );
}



================================================
FILE: frontend/src/components/Hamburger.tsx
================================================
"use client";

import { useRouter } from "next/navigation";
import { useState } from "react";
import { IoMenu as MenuIcon } from "react-icons/io5";
import { LuLogOut as LogoutIcon } from "react-icons/lu";
import {
  Sheet,
  SheetContent,
  SheetFooter,
  SheetHeader,
  SheetOverlay,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet";
import { useUserStore } from "@/store/userStore";
import { Avatar, Button } from "@heroui/react";
import Link from "next/link";

// TODO: add all the new routes here for mobile users
export default function Hamburger() {
  const [open, setOpen] = useState(false);
  const { isLoggedIn, userData, logoutUser } = useUserStore();
  const router = useRouter();

  function handleLogout() {
    logoutUser();
    router.push("/");
    setOpen(false);
  }

  return (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetTrigger>
        <MenuIcon className="h-10 w-10 text-primary sm:hidden" />
      </SheetTrigger>
      <SheetOverlay />

      {isLoggedIn ? (
        <SheetContent className="jusity-between flex h-full flex-col">
          <SheetHeader>
            <Avatar src="" size="lg" className="mx-auto h-32 w-32" />
            <SheetTitle>
              {userData?.firstName} {userData?.lastName}
            </SheetTitle>

            <Button
              variant="solid"
              radius="full"
              className="bg-primary text-white"
              as={Link}
              href="/profile"
              onClick={() => {
                setOpen(false);
              }}
            >
              Show profile
            </Button>

            <Button
              variant="flat"
              radius="full"
              color="primary"
              as={Link}
              href="/saved"
              onClick={() => {
                setOpen(false);
              }}
            >
              Saved Posts
            </Button>

            <Button
              variant="flat"
              radius="full"
              color="primary"
              as={Link}
              href="/upvoted"
              onClick={() => {
                setOpen(false);
              }}
            >
              Upvoted Posts
            </Button>

            <Button
              variant="flat"
              radius="full"
              color="primary"
              as={Link}
              href="/downvoted"
              onClick={() => {
                setOpen(false);
              }}
            >
              Downvoted Posts
            </Button>
          </SheetHeader>

          {/* FIXME: Temporary spacer */}
          <div className="flex-1"></div>

          <SheetFooter>
            <Button
              variant="ghost"
              radius="full"
              color="primary"
              className="font-semibold"
              onClick={handleLogout}
            >
              Logout
              <LogoutIcon className="size-4" />
            </Button>
          </SheetFooter>
        </SheetContent>
      ) : (
        <SheetContent>
          <SheetHeader>
            <SheetTitle>You aren&apos;t logged in</SheetTitle>
            <div className="flex flex-col gap-2">
              <Button
                variant="flat"
                radius="full"
                as={Link}
                href="/login"
                onClick={() => {
                  setOpen(false);
                }}
              >
                Login
              </Button>
              <Button
                variant="solid"
                radius="full"
                className="bg-primary text-white"
                as={Link}
                href="/register"
                onClick={() => {
                  setOpen(false);
                }}
              >
                Sign up
              </Button>
            </div>
          </SheetHeader>
        </SheetContent>
      )}
    </Sheet>
  );
}



================================================
FILE: frontend/src/components/JoinedCommunities.tsx
================================================
import { useRouter } from "next/navigation";
import { BiMessageDots as MessageIcon } from "react-icons/bi";
import { FaUserGroup as PeopleIcon } from "react-icons/fa6";

import { ScrollArea } from "@/components/ui/scroll-area";
import { useUserStore } from "@/store/userStore";
import { Accordion, AccordionItem, Button } from "@heroui/react";
import Link from "next/link";

function JoinedCommunities() {
  const { userData } = useUserStore();
  const router = useRouter();

  return (
    <Accordion variant="light" defaultExpandedKeys={["1"]}>
      <AccordionItem
        key="1"
        aria-label="Joined Communities"
        className="mt-[-10px] pb-0"
        title={
          <div className="flex items-center gap-2 text-[16px]">
            <PeopleIcon className="" />
            Joined Communities
          </div>
        }
      >
        <ScrollArea className="mt-[-8px] h-56 w-full">
          {userData?.communitiesJoined.map((community) => (
            <Button
              key={community}
              variant="flat"
              color="primary"
              className="mb-1 flex h-8 w-60 items-center justify-normal gap-2 pl-6 text-sm"
              aria-label={`c/${community}}`}
              as={Link}
              href={`/c/${community}`}
            >
              <MessageIcon className="mt-1" />
              c/{community}
            </Button>
          ))}
        </ScrollArea>
      </AccordionItem>
    </Accordion>
  );
}

export default JoinedCommunities;



================================================
FILE: frontend/src/components/LoginForm.tsx
================================================
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import { FormEvent, useEffect, useState } from "react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useUserStore } from "@/store/userStore";

export default function LoginForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const { isLoggedIn, loginUser } = useUserStore();
  const router = useRouter();

  useEffect(() => {
    if (isLoggedIn) {
      router.push("/");
    }
  }, [isLoggedIn, router]);

  async function submitForm(e: FormEvent) {
    e.preventDefault();
    loginUser({ email, password });
  }

  return (
    <form onSubmit={(e) => submitForm(e)}>
      <div className="grid gap-4">
        <Button
          variant="default"
          className="w-full"
          type="button"
          onClick={() =>
            loginUser({ email: "test@test.com", password: process.env.NEXT_PUBLIC_DEMO_PASS! })
          }
        >
          Login as a Demo User
        </Button>
        <div className="relative flex justify-center text-xs uppercase">
          <span className="bg-transparent px-2 text-muted-foreground">
            Or continue with
          </span>
        </div>
        <div className="grid gap-2">
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            placeholder="m@example.com"
            autoComplete="email"
            required
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
        </div>
        <div className="grid gap-2">
          <div className="flex items-center">
            <Label htmlFor="password">Password</Label>
            {/* TODO: add this back when we have a password reset feature */}
            {/* <Link href="#" className="ml-auto inline-block text-sm underline">
              Forgot your password?
            </Link> */}
          </div>
          <Input
            id="password"
            type="password"
            required
            // minLength={6}
            autoComplete="current-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
        </div>
        <Button type="submit" className="w-full">
          Login
        </Button>
        {/* TODO: add login with google */}
      </div>
      <div className="mt-4 text-center text-sm">
        Don&apos;t have an account?{" "}
        <Link href="/register" className="underline">
          Sign up
        </Link>
      </div>
    </form>
  );
}



================================================
FILE: frontend/src/components/MutationButton.tsx
================================================
import { Button } from "@heroui/react";
import { BiLoaderAlt as Loader } from "react-icons/bi";

export default function MutationButton({
  onClick,
  isPending,
  children,
  type,
  className,
  size,
  radius,
  id,
}: {
  type?: "button" | "submit";
  onClick?: () => void;
  isPending: boolean;
  children: React.ReactNode;
  className?: string;
  size?: "sm" | "md" | "lg";
  radius?: "sm" | "md" | "lg" | "full" | "none";
  id?: string;
}) {
  return (
    <Button
      type={type}
      color={isPending ? "default" : "primary"}
      onClick={onClick}
      disabled={isPending}
      className={className}
      size={size}
      radius={radius}
      id={id}
    >
      {isPending && <Loader className="mr-2 size-4 animate-spin" />}
      {children}
    </Button>
  );
}



================================================
FILE: frontend/src/components/NavBar.tsx
================================================
import { useUserStore } from "@/store/userStore";
import { Button } from "@heroui/react";
import Link from "next/link";
import { VscGitStash as CodeStashIcon } from "react-icons/vsc";
import AvatarDropdown from "./AvatarDropdown";
import Hamburger from "./Hamburger";
import SearchBar from "./SearchBar";

// TODO: Make this navbar fixed at the top of the screen all the time
export default function Navbar() {
  const { isLoggedIn } = useUserStore();

  return (
    (<nav className="sticky top-0 z-50 mt-[-1rem] flex items-center justify-between bg-background pb-6 pt-4">
      <Button
        className="flex gap-2 font-bold text-primary"
        radius="full"
        variant="light"
        as={Link}
        href="/"
      >
        <CodeStashIcon className="h-8 w-8" />
        <h2 className="mt-1 text-xl font-semibold">CodeStash</h2>
      </Button>
      <Hamburger />
      <SearchBar />
      {isLoggedIn ? (
        // TODO: when user is logged in show them their user icon which opens a menu for lots of actions like reddit does when logged in.
        (<div className="hidden sm:flex">
          <AvatarDropdown />
        </div>)
      ) : (
        <div className="hidden gap-2 sm:flex">
          <Button
            variant="flat"
            color="primary"
            radius="full"
            as={Link}
            href="/login"
          >
            Login
          </Button>
          <Button
            variant="solid"
            radius="full"
            className="bg-primary text-white"
            as={Link}
            href="/register"
          >
            Sign up
          </Button>
        </div>
      )}
    </nav>)
  );
}



================================================
FILE: frontend/src/components/NotLoggedIn.tsx
================================================
"use client";

import { useRouter } from "next/navigation";

import {
  Card,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { cardLayout } from "@/utils/classnames";
import { Avatar, Button } from "@heroui/react";

type PageProps = {
  description: string;
  title: string;
};

export default function NotLoggedIn({ description, title }: PageProps) {
  const router = useRouter();

  // TODO: add title also for each page take as a prop
  return (
    <section className={cn(cardLayout)}>
      <h1 className="mb-4 text-2xl font-bold text-gray-600">{title}</h1>
      <Card>
        <CardHeader className="flex flex-col items-center">
          <Avatar
            src="https://i.seadn.io/gcs/files/ccb8c81826526eb68f002bd3fabaa05c.png?auto=format&dpr=1&w=100"
            size="lg"
            className="mx-auto mb-6 h-32 w-32"
          />
          <CardTitle className="text-lg">You aren&apos;t logged in</CardTitle>
          <CardDescription className="text-center">
            {description}
          </CardDescription>
        </CardHeader>
        <CardFooter className="flex flex-col gap-2">
          <Button
            variant="flat"
            radius="full"
            color="primary"
            className="w-full max-w-80"
            onClick={() => {
              router.push("/login");
            }}
          >
            Login
          </Button>
          <Button
            variant="solid"
            radius="full"
            className="w-full max-w-80 bg-primary text-white"
            onClick={() => {
              router.push("/register");
            }}
          >
            Sign up
          </Button>
        </CardFooter>
      </Card>
    </section>
  );
}



================================================
FILE: frontend/src/components/PostItem.tsx
================================================
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { useUserStore } from "@/store/userStore";
import { PostTypes } from "@/types/postTypes";
import { useAutoAnimate } from "@formkit/auto-animate/react";
import { Button } from "@heroui/react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { BiLoaderAlt as Loader } from "react-icons/bi";

export default function PostItem({ post }: { post: PostTypes }) {
  const router = useRouter();
  const [parent] = useAutoAnimate();
  const { isLoggedIn, upvotePost, userData, downvotePost } = useUserStore();
  const [upvoteCount, setUpvoteCount] = useState(post.upvotes - post.downvotes);
  const [postLoading, setPostLoading] = useState(false);

  // TODO: Create a custom hook to do this
  function handleInteraction(postId: string, action: "upvote" | "downvote") {
    if (!isLoggedIn) {
      router.push("/login");
      return;
    }

    if (action === "upvote") {
      upvotePost(postId);
      if (userData?.upvotedPosts.includes(postId)) {
        setUpvoteCount((count) => count - 1);
      } else {
        if (userData?.downvotedPosts.includes(postId)) {
          setUpvoteCount((count) => count + 2);
        } else {
          setUpvoteCount((count) => count + 1);
        }
      }
    } else if (action === "downvote") {
      downvotePost(postId);
      if (userData?.downvotedPosts.includes(postId)) {
        setUpvoteCount((count) => count + 1);
      } else {
        if (userData?.upvotedPosts.includes(postId)) {
          setUpvoteCount((count) => count - 2);
        } else {
          setUpvoteCount((count) => count - 1);
        }
      }
    }
  }

  return (
    <Card className="border-none drop-shadow-lg">
      <CardHeader className="flex flex-row gap-4">
        {/* <div className="flex flex-col items-center" ref={parent}>
          {userData?.upvotedPosts.includes(post._id) ? (
            <SolidUpvoteIcon
              className="size-5 cursor-pointer"
              onClick={() => handleInteraction(post._id, "upvote")}
            />
          ) : (
            <UpvoteIcon
              className="size-5 cursor-pointer"
              onClick={() => handleInteraction(post._id, "upvote")}
            />
          )}
          {upvoteCount}
          {userData?.downvotedPosts.includes(post._id) ? (
            <SolidDownvoteIcon
              className="size-5 cursor-pointer"
              onClick={() => handleInteraction(post._id, "downvote")}
            />
          ) : (
            <DownvoteIcon
              className="size-5 cursor-pointer"
              onClick={() => handleInteraction(post._id, "downvote")}
            />
          )}
        </div> */}
        <div>
          <CardTitle className="">
            <Link href={`/post/${post._id}`}>{post.title}</Link>
          </CardTitle>
          <CardDescription>
            <Link
              href={
                post.madeBy.username === userData?.username
                  ? "/profile"
                  : `/u/${post.madeBy.username}`
              }
            >
              u/{post.madeBy.username}
            </Link>
          </CardDescription>
        </div>
      </CardHeader>
      <CardContent>
        <p className="whitespace-pre-wrap">
          {post.description.length > 400
            ? post.description.slice(0, 400) + "..."
            : post.description}
        </p>
      </CardContent>
      <CardFooter className="flex flex-col gap-2">
        <p>
          Posted in{" "}
          <Link href={`/c/${post.community}`} className="underline">
            c/{post.community}
          </Link>{" "}
          community
        </p>
        <Button
          color="primary"
          variant={postLoading ? "flat" : "solid"}
          className="w-full rounded-[20px]"
          as={Link}
          href={`/post/${post._id}`}
          onClick={() => setPostLoading(true)}
        >
          {postLoading ? (
            <span className="flex items-center justify-center">
              <Loader className="mr-2 size-4 animate-spin" />
              Loading post...
            </span>
          ) : (
            "Show code"
          )}
        </Button>
      </CardFooter>
    </Card>
  );
}



================================================
FILE: frontend/src/components/Posts.tsx
================================================
"use client";

import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import { PostTypes } from "@/types/postTypes";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { Button, Card, Pagination } from "@heroui/react";
import { useQuery } from "@tanstack/react-query";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { TbError404 as NotFoundIcon } from "react-icons/tb";
import PostItem from "./PostItem";
import PostsLoading from "./skeletons/PostsLoading";
import { CardContent, CardDescription, CardHeader, CardTitle } from "./ui/card";

export default function Posts() {
  const searchParams = useSearchParams();
  const language = searchParams.get("language");
  const router = useRouter();
  const page = parseInt(searchParams.get("page") || "1");
  const { loginUser, isLoggedIn } = useUserStore();

  const { data, isError, isPending, error } = useQuery<{
    posts: PostTypes[];
    totalPages: number;
    totalPosts: number;
    currentPage: number;
  }>({
    queryKey: ["posts", page, language],
    queryFn: () => {
      if (!language) {
        return fetcher.get(`/posts/get-posts?page=${page}`);
      } else {
        return fetcher.post("/posts/get-posts-by-language", { language });
      }
    },
  });

  if (isPending) return <PostsLoading />;
  if (isError) {
    // FIXME: fix ts error
    // @ts-ignore
    if (error?.response?.status === 404) {
      // TODO: add better looking ui for not supported language
      return "This language isn't supported yet";
    }
    return "error";
  }

  return (
    <div className={cn(cardLayout, "flex flex-col gap-8")}>
      {!isLoggedIn && (
        <Card className="md:hidden">
          <CardHeader>
            <CardTitle className="text-lg">Want to see the full app?</CardTitle>
            <CardDescription>
              Login to a demo account to get access to all features of this app
            </CardDescription>
          </CardHeader>
          <CardContent className="w-full">
            <Button
              color="primary"
              className="w-full"
              onClick={() =>
                loginUser({
                  email: "test@test.com",
                  password: process.env.NEXT_PUBLIC_DEMO_PASS!,
                })
              }
            >
              Login as a demo user
            </Button>
          </CardContent>
        </Card>
      )}
      <h1 className="-mb-4 text-2xl font-bold text-gray-600">
        {language ? `Posts written in ${language}` : "All Posts"}
      </h1>
      {data.posts.length === 0 ? (
        <div className="mt-10 flex flex-col items-center justify-center gap-4">
          <NotFoundIcon className="text-[200px] text-secondary" />
          <p>Currenly there are no posts for {language}</p>
          <Button
            as={Link}
            href={`/create-post?language=${language}`}
            color="primary"
            className="drop-shadow-xl"
          >
            Create post in {language}
          </Button>
        </div>
      ) : (
        <>
          {data.posts.map((post) => (
            <PostItem post={post} key={post._id} />
          ))}
          <Pagination
            total={data.totalPages}
            showControls
            page={page}
            className="mx-auto"
            onChange={(page) => {
              if (language) {
                router.push(`?language=${language}&page=${page}`);
              } else {
                router.push(`?page=${page}`);
              }
            }}
          />
        </>
      )}
    </div>
  );
}



================================================
FILE: frontend/src/components/PostsByUsername.tsx
================================================
import { PostTypes } from "@/types/postTypes";
import fetcher from "@/utils/axios";
import { useQuery } from "@tanstack/react-query";
import { TbError404 as NotFoundIcon } from "react-icons/tb";
import PostItem from "./PostItem";
import PostsLoading from "./skeletons/PostsLoading";

export default function PostsByUsername({ username }: { username: string }) {
  const { data, isError, isPending } = useQuery<PostTypes[]>({
    queryKey: ["posts/username", username],
    queryFn: async () => {
      return await fetcher.post("/posts/get-posts-by-username", { username });
    },
  });

  if (isError) return "error";
  if (isPending) return <PostsLoading />;

  return (
    <div className="flex flex-col gap-8">
      <h1 className="-mb-4 text-xl font-bold text-gray-600">
        All Posts by u/{username}
      </h1>
      {data.length === 0 ? (
        <div className="mt-10 flex flex-col items-center justify-center gap-4">
          <NotFoundIcon className="text-[200px] text-secondary" />
          <p>u/{username} hasn&apos;t created any post yet</p>
        </div>
      ) : (
        data.map((post) => <PostItem post={post} key={post._id} />)
      )}
    </div>
  );
}



================================================
FILE: frontend/src/components/PostsNotFound.tsx
================================================
import { useRouter } from "next/navigation";
import React from "react";

import { cn } from "@/lib/utils";
import { cardLayout } from "@/utils/classnames";
import { Button } from "@heroui/react";

import { Card, CardContent, CardHeader } from "./ui/card";
import Link from "next/link";

function PostsNotFound({ description }: { description: string }) {
  const router = useRouter();

  return (
    <Card
      className={cn(
        cardLayout,
        "mt-4 flex flex-col items-center justify-center",
      )}
    >
      {/* TODO: add an icon/svg here for no saved/downvoted/upvoted posts */}
      <CardHeader>
        <h1>{description}</h1>
      </CardHeader>
      <CardContent>
        <Button color="primary" as={Link} href="/">
          Go to homepage
        </Button>
      </CardContent>
    </Card>
  );
}

export default PostsNotFound;



================================================
FILE: frontend/src/components/ProfileCard.tsx
================================================
import {
  BiSolidDownvote as SolidDownvoteIcon,
  BiSolidUpvote as SolidUpvoteIcon,
} from "react-icons/bi";
import { FaBookmark as SaveIcon } from "react-icons/fa";
import {
  IoMdPerson as ProfileIcon,
  IoMdSettings as SettingsIcon,
} from "react-icons/io";
import { useUserStore } from "@/store/userStore";
import { Card, CardBody, CardFooter, CardHeader } from "@heroui/card";
import { Avatar, Button } from "@heroui/react";
import { CardDescription } from "./ui/card";
import Link from "next/link";

export default function ProfileCard() {
  const { userData } = useUserStore();

  return (
    <Card
      shadow="sm"
      className="sticky top-20 z-50 mr-0 hidden max-h-[85vh] w-full max-w-72 p-4 lg:block"
    >
      <CardHeader className="flex flex-col text-center">
        <Link href="/profile">
          <Avatar src={userData?.avatar} className="mx-auto mb-4 h-28 w-28" />
        </Link>
        <h1 className="text-xl">
          {userData?.firstName} {userData?.lastName}
        </h1>
        <CardDescription>u/{userData?.username}</CardDescription>
      </CardHeader>
      <CardBody className="flex w-full flex-col items-center gap-1.5">
        <Button
          variant="solid"
          radius="full"
          color="primary"
          className="flex w-full justify-normal"
          as={Link}
          href="/profile"
        >
          <ProfileIcon className="ml-6 size-5" />
          Show profile
        </Button>

        <Button
          variant="flat"
          radius="md"
          size="md"
          color="primary"
          className="flex w-full justify-normal pl-8"
          as={Link}
          href="/saved"
        >
          <SaveIcon />
          Saved Posts
        </Button>

        <Button
          variant="flat"
          radius="md"
          size="md"
          color="primary"
          className="flex w-full justify-normal pl-8"
          as={Link}
          href="/upvoted"
        >
          <SolidUpvoteIcon />
          Upvoted Posts
        </Button>

        <Button
          variant="flat"
          size="md"
          radius="md"
          color="primary"
          className="flex w-full justify-normal pl-8"
          as={Link}
          href="/downvoted"
        >
          <SolidDownvoteIcon />
          Downvoted Posts
        </Button>
      </CardBody>
      <CardFooter className="absolute bottom-0 left-0 right-0 px-7 pb-4">
        <Button
          variant="flat"
          className="flex w-full justify-normal"
          radius="md"
          color="primary"
          as={Link}
          href="/settings"
        >
          <SettingsIcon className="ml-4 text-lg" />
          Account Settings
        </Button>
      </CardFooter>
    </Card>
  );
}



================================================
FILE: frontend/src/components/RegisterForm.tsx
================================================
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import { FormEvent, useEffect, useState } from "react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useUserStore } from "@/store/userStore";

export default function RegisterForm() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const { isLoggedIn, registerUser, loginUser } = useUserStore();
  const router = useRouter();

  async function submitForm(e: FormEvent) {
    e.preventDefault();
    registerUser({ firstName, lastName, email, password });
  }

  useEffect(() => {
    if (isLoggedIn) {
      router.push("/");
    }
  }, [isLoggedIn, router]);

  return (
    <form onSubmit={submitForm}>
      <div className="grid gap-4">
        <div className="grid grid-cols-2 gap-4">
          <div className="grid gap-2">
            <Label htmlFor="first-name">First name</Label>
            <Input
              id="first-name"
              placeholder="Max"
              autoComplete="given-name"
              required
              value={firstName}
              onChange={(e) => setFirstName(e.target.value)}
            />
          </div>
          <div className="grid gap-2">
            <Label htmlFor="last-name">Last name</Label>
            <Input
              id="last-name"
              placeholder="Robinson"
              required
              autoComplete="family-name"
              value={lastName}
              onChange={(e) => setLastName(e.target.value)}
            />
          </div>
        </div>
        <div className="grid gap-2">
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            placeholder="m@example.com"
            required
            autoComplete="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
        </div>
        <div className="grid gap-2">
          <Label htmlFor="password">Password</Label>
          <Input
            id="password"
            type="password"
            required
            autoComplete="new-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
        </div>
        <Button type="submit" className="w-full">
          Create an account
        </Button>
        {/* <Button variant="outline" className="w-full" type="button">
          Sign up with GitHub
        </Button> */}
      </div>
      <div className="mt-4 text-center text-sm">
        Already have an account?{" "}
        <Link href="/login" className="underline">
          Sign in
        </Link>
      </div>
    </form>
  );
}



================================================
FILE: frontend/src/components/SavedPosts.tsx
================================================
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import NotLoggedIn from "@/components/NotLoggedIn";
import PostsNotFound from "@/components/PostsNotFound";
import PostsLoading from "@/components/skeletons/PostsLoading";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import { PostTypes } from "@/types/postTypes";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { Button } from "@heroui/react";
import { useQuery } from "@tanstack/react-query";

export default function SavedPosts({ hasTitle = true }) {
  const { isLoggedIn, removeSavedPost, userData } = useUserStore();
  const { data, isError, isLoading, refetch, isRefetchError, isRefetching } =
    useQuery<PostTypes[]>({
      queryKey: ["saved-posts"],
      queryFn: async () => {
        // FIXME: make sure to not run the query when user isn't logged in
        // if (isLoggedIn) {
        return await fetcher.get("/posts/get-saved-posts");
        // } else return [];
      },
    });

  const router = useRouter();

  if (!isLoggedIn) {
    return (
      <NotLoggedIn
        title="Saved Posts"
        description="Login or sign up to view your saved posts"
      />
    );
  }

  if (isError || isRefetchError) return "Error";
  if (isLoading || isRefetching)
    return <PostsLoading items={userData?.savedPosts.length || 2} />;

  if (data?.length === 0) {
    return <PostsNotFound description="You haven't saved any posts yet" />;
  }

  return (
    <section className={cn(hasTitle ? cardLayout : "")}>
      {hasTitle && (
        <h1 className="mb-4 text-2xl font-bold text-gray-600">Saved Posts</h1>
      )}
      <div className="flex flex-col gap-4">
        {data?.map((post) => (
          <Card key={post._id}>
            <CardHeader className="flex flex-row items-center gap-4">
              <div>
                <CardTitle className="text-lg">
                  <Link href={`/post/${post._id}`}>{post.title}</Link>
                </CardTitle>
                <CardDescription>
                  <Link href={`/u/${post.madeBy.username}`}>
                    u/{post.madeBy.username}
                  </Link>
                </CardDescription>
              </div>
            </CardHeader>
            <CardContent>
              <p>{post.description}</p>
            </CardContent>
            <CardFooter className="flex flex-col gap-2">
              <p>
                Posted in{" "}
                <Link href={`/c/${post.community}`} className="underline">
                  c/{post.community}
                </Link>{" "}
                community
              </p>
              <Button
                variant="solid"
                className="w-full rounded-[20px] bg-primary text-white"
                as={Link}
                href={`/post/${post._id}`}
              >
                Show code
              </Button>
              <Button
                variant="flat"
                color="primary"
                className="w-full rounded-[20px]"
                onClick={async () => {
                  await removeSavedPost(post._id);
                  refetch();
                }}
              >
                Remove from saved
              </Button>
            </CardFooter>
          </Card>
        ))}
      </div>
    </section>
  );
}



================================================
FILE: frontend/src/components/SearchBar.tsx
================================================
import { Button, Input } from "@heroui/react";
import { FormEvent, useState } from "react";
import { IoMdSearch as SearchIcon } from "react-icons/io";
import { useAutoAnimate } from "@formkit/auto-animate/react";
import { useRouter } from "next/navigation";

export default function SearchBar() {
  const [searchTerm, setSearchTerm] = useState("");
  const [parent] = useAutoAnimate();
  const router = useRouter();

  function handleSubmit(e: FormEvent) {
    e.preventDefault();

    router.push(`/search?query=${searchTerm}`);
  }

  return (
    <form
      className="mr-20 hidden max-w-[700px] items-center gap-4 lg:flex xl:w-full"
      ref={parent}
      onSubmit={handleSubmit}
    >
      <Input
        isClearable
        radius="lg"
        size="md"
        placeholder="Search through code snippets..."
        value={searchTerm}
        onValueChange={(value) => setSearchTerm(value)}
        classNames={{
          input: [
            "text-black/90 dark:text-white/90",
            "placeholder:text-default-700/50 dark:placeholder:text-white/60",
          ],
          inputWrapper: [
            "shadow-md",
            "bg-white",
            "dark:bg-default/60",
            "backdrop-blur-xl",
            "backdrop-saturate-200",
            "hover:bg-default-200/70",
            "dark:hover:bg-default/70",
            "group-data-[focus=true]:bg-default-200/50",
            "dark:group-data-[focus=true]:bg-default/60",
            "!cursor-text",
          ],
        }}
        startContent={
          <SearchIcon className="pointer-events-none mb-0.5 size-5 flex-shrink-0 text-black/50 text-slate-400 dark:text-white/90" />
        }
      />

      {searchTerm && (
        <Button type="submit" color="success" radius="full">
          <SearchIcon className="size-10" />
          Search
        </Button>
      )}
    </form>
  );
}



================================================
FILE: frontend/src/components/SetDownloadPath.tsx
================================================
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { BiLoaderAlt as Loader } from "react-icons/bi";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import fetcher from "@/utils/axios";
import { FormEvent, useState } from "react";
import { useUserStore } from "@/store/userStore";
import { useMutation } from "@tanstack/react-query";
import toast from "react-hot-toast";

export default function SetDownloadPath() {
  const { userData, setUserData } = useUserStore();
  const [downloadPath, setDownloadPath] = useState(
    localStorage.getItem("downloadPath") || userData?.downloadPath || "",
  );
  const { mutate, isPending } = useMutation({
    mutationKey: ["set-download-path"],
    mutationFn: () => {
      const setDownloadPathPromise = fetcher
        .patch("/users/set-download-path", {
          downloadPath,
        })
        .then((res) => {
          setUserData(res.updatedUser);
          setDownloadPath("");
        });

      toast.promise(setDownloadPathPromise, {
        loading: "Setting download path...",
        success: "Download path updated successfully",
        error: "Failed to set download path",
      });

      return setDownloadPathPromise;
    },
  });

  function setPath(e: FormEvent) {
    e.preventDefault();

    // If user is demo user, store download path in local storage
    if (userData?.email === "test@test.com") {
      localStorage.setItem("downloadPath", downloadPath);
      toast.success("Download path updated successfully");
      return;
    }

    mutate();
  }

  return (
    <Card className="mx-auto mb-8">
      <CardHeader>
        <CardTitle className="text-xl">
          {userData?.downloadPath ? "Change" : "Set"} Download Path for VS Code
        </CardTitle>
        <CardDescription>
          Enter the absolute download path of your browser. This is required to
          open files in VS Code. Make sure the folder exists.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={setPath}>
          <div className="grid gap-2" id="change-username">
            <Label htmlFor="email">Download Path</Label>
            <div className="flex items-center justify-center gap-4">
              <Input
                id="download-path"
                placeholder="Enter absolute folder path (e.g., C:/Users/...)"
                required
                value={downloadPath}
                onChange={(e) => setDownloadPath(e.target.value)}
              />
              <Button type="submit" className="w-40" disabled={isPending}>
                {isPending && <Loader className="mr-2 size-4 animate-spin" />}
                Save
              </Button>
            </div>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}



================================================
FILE: frontend/src/components/SideBar.tsx
================================================
import { useUserStore } from "@/store/userStore";
import { Button, Card } from "@heroui/react";
import Link from "next/link";
import { AiFillCode as LangIcon } from "react-icons/ai";
import { FaPlus as PlusIcon } from "react-icons/fa";
import {
  FaUserGroup as PeopleIcon,
  FaUserPlus as UserPlusIcon,
} from "react-icons/fa6";
import { LuLogOut as LogoutIcon } from "react-icons/lu";
import { RiHome6Fill as HomeIcon } from "react-icons/ri";
import JoinedCommunities from "./JoinedCommunities";
import { CardContent, CardDescription, CardHeader, CardTitle } from "./ui/card";

export default function SideBar() {
  const { isLoggedIn, logoutUser, loginUser } = useUserStore();

  function loginDemoUser() {
    loginUser({ email: "test@test.com", password: process.env.NEXT_PUBLIC_DEMO_PASS! });
  }

  return (
    <aside className="hidden h-[85vh] min-w-80 pl-2 pr-10 md:sticky md:top-20 md:block">
      <div className="flex h-full flex-col justify-between">
        <div className="flex flex-col gap-1.5">
          {isLoggedIn && (
            <Button
              className="mb-2 flex w-full justify-normal py-4 pl-14 drop-shadow-md 2xl:py-7"
              radius="full"
              as={Link}
              href="/create-post"
              size="lg"
              color="primary"
            >
              <PlusIcon className="ml-4 text-lg" />
              Create Post
            </Button>
          )}
          <Button
            variant="flat"
            className="flex w-full justify-normal"
            radius="md"
            color="primary"
            as={Link}
            href="/"
          >
            <HomeIcon className="ml-4 text-lg" />
            Home
          </Button>
          <Button
            variant="flat"
            className="flex w-full justify-normal"
            radius="md"
            color="primary"
            as={Link}
            href="/communities"
          >
            <PeopleIcon className="ml-4 text-lg" />
            Communities
          </Button>
          <Button
            variant="flat"
            className="flex w-full justify-normal"
            radius="md"
            color="primary"
            as={Link}
            href="/languages"
          >
            <LangIcon className="ml-4 text-lg" />
            Popular languages
          </Button>
          {isLoggedIn && (
            <>
              <Button
                variant="flat"
                color="primary"
                className="flex w-full justify-normal"
                aria-label="create community"
                as={Link}
                href="/create-community"
              >
                <UserPlusIcon className="ml-4 text-lg" />
                Create Community
              </Button>
              <JoinedCommunities />
            </>
          )}
        </div>

        {/* // TODO: add ui here for not logged in user */}
        {isLoggedIn ? (
          <Button
            variant="flat"
            className="flex w-full justify-normal hover:text-danger-500"
            radius="md"
            color="primary"
            onClick={logoutUser}
          >
            <LogoutIcon className="ml-4 text-lg" />
            Logout
          </Button>
        ) : (
          <Card className="max-w-80">
            <CardHeader>
              <CardTitle className="text-lg">
                Want to see the full app?
              </CardTitle>
              <CardDescription>
                Login to a demo account to get access to all features of this
                app
              </CardDescription>
            </CardHeader>
            <CardContent className="w-full">
              <Button
                color="primary"
                className="w-full"
                onClick={loginDemoUser}
              >
                Login as a demo user
              </Button>
            </CardContent>
          </Card>
        )}
      </div>
    </aside>
  );
}



================================================
FILE: frontend/src/components/theme-provider.tsx
================================================
"use client";

import { ThemeProvider as NextThemesProvider } from "next-themes";
import { ThemeProviderProps } from "next-themes/dist/types";
import * as React from "react";

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}



================================================
FILE: frontend/src/components/UpdateUsername.tsx
================================================
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useUserStore } from "@/store/userStore";
import fetcher from "@/utils/axios";
import { useMutation } from "@tanstack/react-query";
import { FormEvent, useState } from "react";
import toast from "react-hot-toast";
import { BiLoaderAlt as Loader } from "react-icons/bi";

// TODO: check if username is available, if not: send a toast to say "Username taken"
export default function UpdateUsername() {
  const [newUsername, setNewUsername] = useState("");
  const { setUserData } = useUserStore();
  const { userData } = useUserStore();
  const { mutate, isPending } = useMutation({
    mutationKey: ["update-username"],
    mutationFn: () => {
      const updateUsernamePromise = fetcher
        .patch("/users/update-username", {
          newUsername,
        })
        .then((res) => {
          setUserData(res.updatedUser);
          setNewUsername("");
        });

      toast.promise(updateUsernamePromise, {
        loading: "Updating username...",
        success: "Username updated successfully",
        error: "Failed to update username",
      });

      return updateUsernamePromise;
    },
  });

  function updateUsername(e: FormEvent) {
    e.preventDefault();

    if (userData?.email === "test@test.com") {
      toast.error("You can't change the username of the demo user");
      return;
    }

    mutate();
  }

  return (
    <Card className="mx-auto mb-8">
      <CardHeader>
        <CardTitle className="text-xl">Change Username</CardTitle>
        <CardDescription>Create a new username below</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={updateUsername}>
          <div className="grid gap-2">
            <Label htmlFor="email">New username</Label>
            <div className="flex items-center justify-center gap-4">
              <Input
                id="username"
                placeholder="thorfinn"
                autoComplete="username"
                required
                value={newUsername}
                onChange={(e) => setNewUsername(e.target.value)}
              />
              <Button type="submit" className="w-40" disabled={isPending}>
                {isPending && <Loader className="mr-2 size-4 animate-spin" />}
                Save
              </Button>
            </div>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}



================================================
FILE: frontend/src/components/UploadAvatar.tsx
================================================
import React, { FormEvent, useState } from "react";
import {
  Modal,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalFooter,
  Button,
  useDisclosure,
  Input,
} from "@heroui/react";
import toast from "react-hot-toast";
import { axiosInstance } from "@/utils/axios";
import { useUserStore } from "@/store/userStore";
import { FaImagePortrait as AvatarIcon } from "react-icons/fa6";

export default function UploadAvatar({
  buttonText,
  type,
  communityName,
  refetch,
}: {
  buttonText: string;
  communityName?: string;
  refetch?: () => void;
  type: "user" | "community";
}) {
  const { isOpen, onOpen, onOpenChange } = useDisclosure();
  const [avatar, setAvatar] = useState<File>();
  const { setUserData } = useUserStore();

  function uploadAvatar(e: FormEvent) {
    e.preventDefault();

    if (!avatar) {
      toast.error("Please upload avatar file");
      return;
    }

    if (!["image/jpeg", "image/png"].includes(avatar?.type)) {
      toast.error("Only jpeg and png files are allowed");
      return;
    }

    const formData = new FormData();
    formData.append("avatar", avatar);

    let postRoute;
    if (type === "user") {
      postRoute = "/users/upload-avatar";
    } else {
      postRoute = "/community/upload-avatar";
      formData.append("name", communityName!);
    }

    const toastPromise = axiosInstance
      .post(postRoute, formData, {
        headers: {
          "Content-Type": "multipart/form-data",
        },
      })
      .then((res) => {
        if (type === "user") setUserData(res.data.data.user);
        else refetch!();
      });

    toast.promise(toastPromise, {
      loading: "Saving avatar...",
      success: "Saved avatar",
      error: "Error saving avatar",
    });
  }

  return (
    <>
      <Button onPress={onOpen} color="primary" radius="md" size="sm">
        <AvatarIcon />
        {buttonText}
      </Button>
      <Modal isOpen={isOpen} onOpenChange={onOpenChange}>
        <ModalContent>
          {(onClose) => (
            <>
              <ModalHeader className="flex flex-col gap-1">
                {buttonText}
              </ModalHeader>
              <form onSubmit={uploadAvatar}>
                <ModalBody>
                  <p>1 : 1 image ratio recommended.</p>
                  <Input
                    color="primary"
                    type="file"
                    id="avatar"
                    name="avatar"
                    accept="image/png, image/jpeg"
                    onChange={(e) => {
                      if (!e.target.files) return;
                      setAvatar(e.target.files[0]);
                    }}
                  />
                </ModalBody>
                <ModalFooter>
                  <Button color="danger" variant="light" onPress={onClose}>
                    Close
                  </Button>
                  <Button color="primary" onPress={onClose} type="submit">
                    Save
                  </Button>
                </ModalFooter>
              </form>
            </>
          )}
        </ModalContent>
      </Modal>
    </>
  );
}



================================================
FILE: frontend/src/components/UploadCoverImage.tsx
================================================
import React, { FormEvent, useState } from "react";
import {
  Modal,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalFooter,
  Button,
  useDisclosure,
  Input,
} from "@heroui/react";
import toast from "react-hot-toast";
import { axiosInstance } from "@/utils/axios";
import Link from "next/link";
import { FiExternalLink as LinkIcon } from "react-icons/fi";
import { FaRegImage as CoverImageIcon } from "react-icons/fa";

export default function UploadCoverImage({
  buttonText,
  communityName,
  refetch,
}: {
  buttonText: string;
  communityName: string;
  refetch: () => void;
}) {
  const { isOpen, onOpen, onOpenChange } = useDisclosure();
  const [coverImage, setCoverImage] = useState<File>();

  function uploadCoverImage(e: FormEvent) {
    e.preventDefault();

    if (!coverImage) {
      toast.error("Please upload cover image file");
      return;
    }

    if (!["image/jpeg", "image/png"].includes(coverImage?.type)) {
      toast.error("Only jpeg and png files are allowed");
      return;
    }

    const formData = new FormData();
    formData.append("cover-image", coverImage);
    formData.append("name", communityName);

    const toastPromise = axiosInstance
      .post("/community/upload-cover-image", formData, {
        headers: {
          "Content-Type": "multipart/form-data",
        },
      })
      .then(() => {
        refetch();
      });

    toast.promise(toastPromise, {
      loading: "Saving cover image...",
      success: "Saved cover image",
      error: "Error saving cover image",
    });
  }

  return (
    <>
      <Button onPress={onOpen} color="primary" radius="md" size="sm">
        <CoverImageIcon />
        {buttonText}
      </Button>
      <Modal isOpen={isOpen} onOpenChange={onOpenChange}>
        <ModalContent>
          {(onClose) => (
            <>
              <ModalHeader className="flex flex-col gap-1">
                {buttonText}
              </ModalHeader>
              <form onSubmit={uploadCoverImage}>
                <ModalBody>
                  <p>4 : 1 image ratio recommended.</p>
                  <Input
                    color="primary"
                    type="file"
                    id="cover-image"
                    name="cover-image"
                    accept="image/png, image/jpeg"
                    onChange={(e) => {
                      if (!e.target.files) return;
                      setCoverImage(e.target.files[0]);
                    }}
                  />
                </ModalBody>
                <ModalFooter>
                  <Button color="danger" variant="light" onPress={onClose}>
                    Close
                  </Button>
                  <Button color="primary" onPress={onClose} type="submit">
                    Save
                  </Button>
                </ModalFooter>
              </form>
            </>
          )}
        </ModalContent>
      </Modal>
    </>
  );
}



================================================
FILE: frontend/src/components/UpvotedPosts.tsx
================================================
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import NotLoggedIn from "@/components/NotLoggedIn";
import PostsNotFound from "@/components/PostsNotFound";
import PostsLoading from "@/components/skeletons/PostsLoading";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { useUserStore } from "@/store/userStore";
import { PostTypes } from "@/types/postTypes";
import fetcher from "@/utils/axios";
import { cardLayout } from "@/utils/classnames";
import { Button } from "@heroui/react";
import { useQuery } from "@tanstack/react-query";

export default function UpvotedPosts({ hasTitle = true }) {
  const { isLoggedIn, userData } = useUserStore();
  const { data, isError, isLoading } = useQuery<PostTypes[]>({
    queryKey: ["upvoted-posts"],
    queryFn: async () => {
      if (userData?.upvotedPosts.length === 0) {
        return [];
      }
      return await fetcher.get("/posts/get-upvoted");
    },
  });

  const router = useRouter();

  if (!isLoggedIn) {
    return (
      <NotLoggedIn
        title="Upvoted Posts"
        description="Login or sign up to view your upvoted posts"
      />
    );
  }
  if (isError) return "Error";
  if (isLoading)
    return <PostsLoading items={userData?.upvotedPosts.length || 4} />;

  if (data?.length === 0) {
    return <PostsNotFound description="You haven't upvoted any posts yet" />;
  }

  return (
    <section className={cn(hasTitle ? cardLayout : "")}>
      {hasTitle && (
        <h1 className="mb-4 text-2xl font-bold text-gray-600">Upvoted Posts</h1>
      )}
      <div className="flex flex-col gap-8">
        {data?.map((post) => (
          <Card key={post._id}>
            <CardHeader className="flex flex-row items-center gap-4">
              <div>
                <CardTitle className="text-lg">
                  <Link href={`/post/${post._id}`}>{post.title}</Link>
                </CardTitle>
                <CardDescription>
                  <Link href={`/u/${post.madeBy.username}`}>
                    u/{post.madeBy.username}
                  </Link>
                </CardDescription>
              </div>
            </CardHeader>
            <CardContent>
              <p>{post.description}</p>
            </CardContent>
            <CardFooter className="flex flex-col gap-2">
              <p>
                Posted in{" "}
                <Link href={`/c/${post.community}`} className="underline">
                  c/{post.community}
                </Link>{" "}
                community
              </p>
              <Button
                variant="solid"
                className="w-full rounded-[20px] bg-primary text-white"
                as={Link}
                href={`/post/${post._id}`}
              >
                Show code
              </Button>
              {/* TODO: Maybe add a remove from upvotes button here? */}
              {/* <Button
              variant="flat"
              color="primary"
              className="w-full rounded-[20px]"
              // onClick={async () => {
              //   await removeSavedPost(post._id);
              //   refetch();
              // }}
            >
              Remove from saved
            </Button> */}
            </CardFooter>
          </Card>
        ))}
      </div>
    </section>
  );
}



================================================
FILE: frontend/src/components/UserPosts.tsx
================================================
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import PostsNotFound from "@/components/PostsNotFound";
import PostsLoading from "@/components/skeletons/PostsLoading";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { useUserStore } from "@/store/userStore";
import { PostTypes } from "@/types/postTypes";
import fetcher from "@/utils/axios";
import { Button } from "@heroui/react";
import { useQuery } from "@tanstack/react-query";

export default function UserPosts() {
  const { userData } = useUserStore();
  const { data, isError, isLoading } = useQuery<PostTypes[]>({
    queryKey: ["user-posts"],
    queryFn: () => {
      return fetcher.post("/posts/get-posts-by-username", {
        username: userData?.username,
      });
    },
  });

  const router = useRouter();

  if (isError) return "Error";
  if (isLoading) return <PostsLoading items={2} />;

  if (data?.length === 0) {
    return <PostsNotFound description="You haven't created any posts yet" />;
  }

  return (
    <section>
      {/* <h1 className="mb-4 text-2xl font-bold text-gray-600">Your Posts</h1> */}
      <div className="flex flex-col gap-8">
        {data?.map((post) => (
          <Card key={post._id}>
            <CardHeader className="flex flex-row items-center gap-4">
              <div>
                <CardTitle className="text-lg">
                  <Link href={`/post/${post._id}`}>{post.title}</Link>
                </CardTitle>
                <CardDescription>
                  <Link href={`/u/${post.madeBy.username}`}>
                    u/{post.madeBy.username}
                  </Link>
                </CardDescription>
              </div>
            </CardHeader>
            <CardContent>
              <p>{post.description}</p>
            </CardContent>
            <CardFooter className="flex flex-col gap-2">
              <p>
                Posted in{" "}
                <Link href={`/c/${post.community}`} className="underline">
                  c/{post.community}
                </Link>{" "}
                community
              </p>
              <Button
                variant="solid"
                className="w-full rounded-[20px] bg-primary text-white"
                as={Link}
                href={`/post/${post._id}`}
              >
                Show code
              </Button>
              {/* TODO: Maybe add a remove from upvotes button here? */}
              {/* <Button
              variant="flat"
              color="primary"
              className="w-full rounded-[20px]"
              // onClick={async () => {
              //   await removeSavedPost(post._id);
              //   refetch();
              // }}
            >
              Remove from saved
            </Button> */}
            </CardFooter>
          </Card>
        ))}
      </div>
    </section>
  );
}



================================================
FILE: frontend/src/components/animations/FullPagePreLoader.tsx
================================================
import { Progress } from "@heroui/react";
import { VscGitStash as CodeStashIcon } from "react-icons/vsc";

export default function FullPagePreLoader() {
  return (
    <div className="flex h-[85vh] items-center justify-center">
      <div className="flex flex-col items-center justify-center text-center gap-2">
        <h1 className="text-5xl font-bold text-primary flex items-end gap-4">
          <CodeStashIcon className="h-16 w-16" />
          CodeStash
        </h1>
        <Progress size="md" isIndeterminate aria-label="Loading..." />
      </div>
    </div>
  );
}



================================================
FILE: frontend/src/components/buttons/BackButton.tsx
================================================
import { useRouter } from "next/navigation";
import { IoMdArrowRoundBack as BackIcon } from "react-icons/io";

import { Button } from "@heroui/react";

export default function BackButton() {
  const router = useRouter();

  return (
    <Button
      className="mb-2"
      color="primary"
      variant="solid"
      onClick={router.back}
    >
      <BackIcon />
      Go back
    </Button>
  );
}



================================================
FILE: frontend/src/components/buttons/CopyCodeButton.tsx
================================================
"use client";

import {
  LuClipboardCheck as CheckIcon,
  LuClipboardCopy as CopyIcon,
} from "react-icons/lu";

import { Button } from "@heroui/react";
import { useCopyToClipboard } from "@uidotdev/usehooks";

export default function CopyCodeButton({ code }: { code: string }) {
  const [copiedText, copyToClipboard] = useCopyToClipboard();
  const hasCopiedText = Boolean(copiedText);

  return (
    <Button
      // variant="ghost"
      color="primary"
      radius="full"
      // className="w-full py-4 text-lg"
      className="w-full"
      onClick={() => copyToClipboard(code)}
    >
      {hasCopiedText ? (
        <>
          <CheckIcon className="size-5" />
          Copied!
        </>
      ) : (
        <>
          <CopyIcon className="size-5" />
          Copy to clipboard
        </>
      )}
    </Button>
  );
}



================================================
FILE: frontend/src/components/buttons/DeletePostButton.tsx
================================================
import { queryClient } from "@/app/providers";
import { Button as ShadButton } from "@/components/ui/button";
import fetcher from "@/utils/axios";
import {
  Button,
  Modal,
  ModalBody,
  ModalContent,
  ModalFooter,
  ModalHeader,
  useDisclosure,
} from "@heroui/react";
import { useMutation } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import toast from "react-hot-toast";
import { MdDelete as DeleteIcon } from "react-icons/md";

export default function DeletePostButton({ postId }: { postId: string }) {
  const { isOpen, onOpen, onOpenChange, onClose } = useDisclosure();
  const router = useRouter();
  const { mutate: deletePost } = useMutation({
    mutationKey: ["delete-post"],
    onSuccess: () => {
      queryClient.invalidateQueries();
      router.push("/");
    },
    mutationFn: async () => {
      const deletePostPromise = fetcher.post("/posts/delete-post", { postId });

      toast.promise(deletePostPromise, {
        loading: "Deleting post...",
        success: "Deleted post successfully",
        error: "Failed to delete post",
      });

      onClose();

      return deletePostPromise;
    },
  });

  return (
    <>
      <ShadButton
        className="text-sm text-black hover:text-red-500"
        variant="link"
        size="sm"
        onClick={onOpen}
      >
        <DeleteIcon className="mr-1 size-4" />
        Delete Post
      </ShadButton>
      <Modal isOpen={isOpen} onOpenChange={onOpenChange} backdrop="blur">
        <ModalContent>
          {(onClose) => (
            <>
              <ModalHeader className="flex flex-col gap-1">
                Are you sure that you want to delete this post?
              </ModalHeader>
              <ModalBody>
                <p>
                  This action cannot be undone. This will permanently delete
                  your post and all its comments.
                </p>
              </ModalBody>
              <ModalFooter>
                <Button color="danger" variant="light" onPress={onClose}>
                  Close
                </Button>
                <Button color="primary" onClick={() => deletePost()}>
                  Delete Post
                </Button>
              </ModalFooter>
            </>
          )}
        </ModalContent>
      </Modal>
    </>
  );
}



================================================
FILE: frontend/src/components/buttons/ExplainThis.tsx
================================================
import { useUserStore } from "@/store/userStore";
import { axiosInstance } from "@/utils/axios";
import { infoToast } from "@/utils/constants";
import { Button } from "@heroui/react";
import { useRouter } from "next/navigation";
import React from "react";
import toast from "react-hot-toast";
import { BsStars as StarsIcon } from "react-icons/bs";

export default function ExplainThisButton({
  postId,
  setAiAnswer,
}: {
  postId: string;
  setAiAnswer: React.Dispatch<React.SetStateAction<string | undefined>>;
}) {
  const { isLoggedIn } = useUserStore();
  const router = useRouter();
  function getAiAnswer() {
    if (!isLoggedIn) {
      infoToast(
        "You must be logged in to use AI features. Login as a demo user to test this feature.",
      );
      return;
    }

    const aiAnswerPromise = axiosInstance
      .get("/ai/explain", { params: { postId } })
      .then((res) => {
        setAiAnswer(res.data.data.aiAnswer);
        router.push(`#ai-explanation`);
      });

    toast.promise(aiAnswerPromise, {
      loading: "Generating AI Explanation...",
      success: "Generated AI Explanation",
      error: "Our AI is currently under heavy load. Please try again later.",
    });
  }

  return (
    <Button
      className="mb-2"
      color="primary"
      variant="flat"
      onClick={getAiAnswer}
    >
      <StarsIcon className="size-5" />
      Explain this
    </Button>
  );
}



================================================
FILE: frontend/src/components/buttons/UploadCodeFromFile.tsx
================================================
import React, { useState } from "react";
import {
  Modal,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalFooter,
  Button,
  useDisclosure,
  Input,
} from "@heroui/react";
import toast from "react-hot-toast";
import { MdOutlineUploadFile as UploadIcon } from "react-icons/md";
import { allowedLanguages } from "@/utils/constants";

// Map allowed languages to their file extensions
const languageExtensions = {
  javascript: [".js"],
  python: [".py"],
  typescript: [".ts"],
  ruby: [".rb"],
  java: [".java"],
  cpp: [".cpp", ".h"],
  go: [".go"],
  php: [".php"],
  swift: [".swift"],
};

export default function UploadCodeFromFile({
  setCode,
}: {
  setCode: React.Dispatch<React.SetStateAction<string>>;
}) {
  const { isOpen, onOpen, onOpenChange } = useDisclosure();
  const [file, setFile] = useState<File>();

  function handleSubmit() {
    if (!file) {
      toast.error("Please upload code file");
      return;
    }

    const fileName = file.name;
    const fileExtension = fileName
      .slice(fileName.lastIndexOf("."))
      .toLowerCase();

    // Check if the extension is allowed
    let isAllowed = false;
    for (const language of allowedLanguages) {
      if (languageExtensions[language].includes(fileExtension)) {
        isAllowed = true;
        break;
      }
    }

    if (isAllowed) {
      const reader = new FileReader();
      reader.onload = function (e) {
        if (!e.target) return;
        if (typeof e.target.result !== "string") return;
        setCode(e.target.result);
      };
      reader.readAsText(file);
    } else {
      toast.error("Invalid file type! Please upload a valid code file.");
    }
  }

  return (
    <>
      <Button onPress={onOpen} color="primary" radius="md" size="sm">
        <UploadIcon />
        Upload File
      </Button>
      <Modal isOpen={isOpen} onOpenChange={onOpenChange}>
        <ModalContent>
          {(onClose) => (
            <>
              <ModalHeader className="flex flex-col gap-1">
                Upload file
              </ModalHeader>
              <div>
                <ModalBody>
                  <p>Upload a valid code file.</p>
                  <Input
                    color="primary"
                    type="file"
                    id="code-file"
                    name="code-file"
                    onChange={(e) => {
                      if (!e.target.files) return;
                      setFile(e.target.files[0]);
                    }}
                  />
                </ModalBody>
                <ModalFooter>
                  <Button
                    color="danger"
                    variant="light"
                    onPress={onClose}
                    type="button"
                  >
                    Close
                  </Button>
                  <Button
                    color="primary"
                    onPress={onClose}
                    type="button"
                    onClick={handleSubmit}
                  >
                    Save
                  </Button>
                </ModalFooter>
              </div>
            </>
          )}
        </ModalContent>
      </Modal>
    </>
  );
}



================================================
FILE: frontend/src/components/buttons/UploadCodeFromGithub.tsx
================================================
import React, { FormEvent, useState } from "react";
import {
  Modal,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalFooter,
  Button,
  useDisclosure,
  Input,
} from "@heroui/react";
import toast from "react-hot-toast";
import { FaGithub as GithubIcon } from "react-icons/fa";

import axios from "axios";

function parseUrl(url: string) {
  if (!url.startsWith("https://")) {
    url = `https://${url}`;
  }

  // Do not modify if the URL is already in raw Gist format
  if (url.startsWith("https://gist.githubusercontent.com")) {
    return url;
  }

  // Handle Gist URLs
  if (url.startsWith("https://gist.github.com")) {
    // Convert the URL to raw Gist format
    const gistRawLink = url
      .replace("gist.github.com", "gist.githubusercontent.com")
      .concat("/raw");
    return gistRawLink;
  }

  if (
    !url.startsWith("https://github.com/") &&
    !url.startsWith("https://raw.githubusercontent.com/")
  ) {
    toast("Please provide a valid GitHub URL");
    return;
  }

  // Convert regular GitHub URLs to raw format
  const rawLink = url
    .replace("github.com", "raw.githubusercontent.com")
    .replace("/blob/", "/");

  return rawLink;
}

export default function UploadCodeFromGithub({
  setCode,
}: {
  setCode: React.Dispatch<React.SetStateAction<string>>;
}) {
  const [githubUrl, setGithubUrl] = useState("");
  const { isOpen, onOpen, onOpenChange } = useDisclosure();

  function handleSubmit() {
    if (!githubUrl) {
      toast.error("Github Url is required to upload code from Github.");
      return;
    }

    const rawLink = parseUrl(githubUrl);
    if (!rawLink) return;

    const toastPromise = axios.get(rawLink).then((res) => {
      setCode(res.data);
      setGithubUrl("");
    });

    toast.promise(toastPromise, {
      loading: "Uploading code from github...",
      success: "Code uploaded successfully",
      error: "Failed to upload code",
    });
  }

  return (
    <>
      <Button
        onPress={onOpen}
        color="primary"
        radius="md"
        size="sm"
        type="button"
      >
        <GithubIcon />
        Upload from Github
      </Button>
      <Modal isOpen={isOpen} onOpenChange={onOpenChange} size="lg">
        <ModalContent>
          {(onClose) => (
            <>
              <ModalHeader className="flex flex-col gap-1">
                Upload Code from Github
              </ModalHeader>
              <div>
                <ModalBody>
                  <p className="text-sm text-gray-700">
                    Enter the github url of the file that you want to upload,
                    the repository must be public for this to work.
                  </p>
                  <Input
                    // type="url"
                    label="Github Url"
                    required
                    placeholder="github.com/username/repository/blob/main/file"
                    labelPlacement="outside"
                    value={githubUrl}
                    onChange={(e) => setGithubUrl(e.target.value)}
                    startContent={
                      <div className="pointer-events-none flex items-center">
                        <span className="text-small text-default-400">
                          https://
                        </span>
                      </div>
                    }
                  />
                </ModalBody>
                <ModalFooter>
                  <Button color="danger" variant="light" onPress={onClose}>
                    Close
                  </Button>
                  <Button
                    color="primary"
                    type="button"
                    onPress={onClose}
                    onClick={handleSubmit}
                  >
                    Upload
                  </Button>
                </ModalFooter>
              </div>
            </>
          )}
        </ModalContent>
      </Modal>
    </>
  );
}



================================================
FILE: frontend/src/components/buttons/VSCodeButton.tsx
================================================
import { useUserStore } from "@/store/userStore";
import {
  Modal,
  ModalBody,
  ModalContent,
  ModalFooter,
  ModalHeader,
  useDisclosure,
} from "@heroui/modal";
import { Button } from "@heroui/react";
import Link from "next/link";
import { useState } from "react";
import toast from "react-hot-toast";
import { IoCodeDownload as DownloadIcon } from "react-icons/io5";
import { VscVscode as VSCodeIcon } from "react-icons/vsc";

type VSCodeButtonProps = {
  snippet: string;
  fileName: string;
  fileType: string;
};

function getFileExtension(language: string): string | null {
  switch (language.toLowerCase()) {
    case "javascript":
      return "js";
    case "python":
      return "py";
    case "typescript":
      return "ts";
    case "ruby":
      return "rb";
    case "java":
      return "java";
    case "cpp":
      return "cpp";
    case "go":
      return "go";
    case "php":
      return "php";
    case "swift":
      return "swift";
    default:
      return null; // return null if the language is not allowed
  }
}

export default function VSCodeButton({
  snippet,
  fileName,
  fileType,
}: VSCodeButtonProps) {
  const fileExtension = getFileExtension(fileType);
  const { isOpen, onOpen, onOpenChange, onClose } = useDisclosure();
  const [hasDownloaded, setHasDownloaded] = useState(false);
  const { userData } = useUserStore();

  function downloadFile() {
    const blob = new Blob([snippet], { type: `text/${fileType}` });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${fileName}.${fileExtension}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);

    toast.success("File downloaded successfully");
    setHasDownloaded(true);
  }

  function handleModalOpen() {
    if (localStorage.getItem("downloadPath")) {
      userData!.downloadPath = localStorage.getItem("downloadPath")!;
    }

    if (userData?.email === "test@test.com") {
      toast.error("Demo user can't use this feature");
      return;
    }

    if (!userData?.downloadPath) {
      // TODO: maybe make all toasts custom
      toast.custom(
        (t) => (
          <div
            className={`${t.visible ? "animate-enter" : "animate-leave"} flex items-center justify-center gap-4 rounded-xl bg-white px-6 py-2 shadow-xl`}
          >
            <span>
              <span className="mr-4">ğŸ“Œ</span> You need to set the download path
              first in Account Settings
            </span>
            <Button
              as={Link}
              href="/settings"
              size="sm"
              color="primary"
              radius="full"
            >
              Account Settings
            </Button>
          </div>
        ),
        {
          id: "download-path-not-set",
        },
      );
      return;
    }
    onOpen();
  }

  function openInVSCode() {
    if (!userData?.downloadPath) {
      toast.custom(
        <div>
          You need to set the download path first in Account Settings
          <Button as={Link} href="/settings">
            Account Settings
          </Button>
        </div>,
      );
      return;
    }
    if (!hasDownloaded) {
      toast.error("You need to download the file first");
      return;
    }
    if (userData.downloadPath.endsWith("/")) {
      window.location.href = `vscode://file${userData.downloadPath}/${fileName}.${fileExtension}`;
    } else if (userData.downloadPath.endsWith("\\")) {
      window.location.href = `vscode://file${userData.downloadPath}\\${fileName}.${fileExtension}`;
    } else {
      window.location.href = `vscode://file${userData.downloadPath}/${fileName}.${fileExtension}`;
    }
  }

  return (
    <div className="flex gap-2 self-end">
      <Button
        color="success"
        radius="full"
        variant="flat"
        size="sm"
        onClick={downloadFile}
      >
        <DownloadIcon className="size-6" />
        Download
      </Button>

      <Button
        color="primary"
        radius="full"
        variant="flat"
        size="sm"
        onPress={handleModalOpen}
      >
        <VSCodeIcon className="size-6" />
        Open in VS Code
      </Button>

      <Modal isOpen={isOpen} onOpenChange={onOpenChange}>
        <ModalContent>
          {(onClose) => (
            <>
              <ModalHeader className="flex items-center gap-2">
                <VSCodeIcon className="size-6 text-primary" />
                Download & Open in VS Code
              </ModalHeader>
              <ModalBody>
                <p>You have to download the file before opening.</p>
                <Button
                  color={hasDownloaded ? "default" : "success"}
                  radius="md"
                  onClick={downloadFile}
                  disabled={hasDownloaded}
                >
                  <DownloadIcon className="size-6" />
                  {hasDownloaded ? "Downloaded!" : "Download File"}
                </Button>
              </ModalBody>
              <ModalFooter>
                <Button color="danger" variant="light" onPress={onClose}>
                  Close
                </Button>
                <Button
                  color={hasDownloaded ? "primary" : "default"}
                  onClick={openInVSCode}
                  type="submit"
                  disabled={!hasDownloaded}
                >
                  Open in VS Code
                </Button>
              </ModalFooter>
            </>
          )}
        </ModalContent>
      </Modal>
    </div>
  );
}



================================================
FILE: frontend/src/components/skeletons/CommentsSkeleton.tsx
================================================
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Skeleton, Textarea } from "@heroui/react";

export default function CommentsSkeleton() {
  return (
    <Card className="my-6">
      <CardHeader>
        <CardTitle>0 Comments</CardTitle>
        <Textarea
          variant="underlined"
          required
          color="primary"
          placeholder="Add a comment"
          className="col-span-12 mb-3 h-10 md:col-span-6"
        />
      </CardHeader>
      {[1, 2, 3, 4].map((_, index) => (
        <CardContent key={index}>
          <Skeleton className="mb-2 h-4 w-52 rounded-2xl" />
          <Skeleton className="h-14 rounded-2xl" />
        </CardContent>
      ))}
    </Card>
  );
}



================================================
FILE: frontend/src/components/skeletons/CommunitiesSkeleton.tsx
================================================
import { cn } from "@/lib/utils";
import { cardLayout } from "@/utils/classnames";
import { Button, Skeleton } from "@heroui/react";

import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from "../ui/card";

export default function CommunitiesSkeleton() {
  return (
    <>
      {Array.from({ length: 4 }).map((_, index) => (
        <Card className={cn("mb-4", cardLayout)} key={index}>
          <CardHeader>
            <CardTitle>
              <Skeleton className="h-10 rounded-2xl" />
              <Skeleton className="mt-3 h-4 w-52 rounded-sm" />
            </CardTitle>
          </CardHeader>
          <CardContent>
            <Skeleton className="h-32 rounded-2xl" />
          </CardContent>
          <CardFooter>
            <Button color="primary" isLoading className="w-full">
              View Community
            </Button>
          </CardFooter>
        </Card>
      ))}
    </>
  );
}



================================================
FILE: frontend/src/components/skeletons/PostSkeleton.tsx
================================================
import { cn } from "@/lib/utils";
import { cardLayout } from "@/utils/classnames";
import { Button, Skeleton } from "@heroui/react";

import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from "../ui/card";

export default function PostSkeleton() {
  return (
    <Card className={cn(cardLayout)}>
      <CardHeader>
        <CardTitle>
          <Skeleton className="h-10 rounded-2xl" />
          <Skeleton className="mt-3 h-4 w-52 rounded-sm" />
        </CardTitle>
      </CardHeader>
      <CardContent>
        <Skeleton className="h-52 rounded-2xl" />
      </CardContent>
      <CardFooter>
        <Button
          variant="flat"
          color="primary"
          radius="full"
          isLoading
          className="w-full text-lg"
        >
          Save post
        </Button>
      </CardFooter>
    </Card>
  );
}



================================================
FILE: frontend/src/components/skeletons/PostsLoading.tsx
================================================
import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { cardLayout } from "@/utils/classnames";
import { Button, Skeleton } from "@heroui/react";

export default function PostsLoading({ items }: { items?: number }) {
  const itemCount = items ? items : 4;

  return (
    <>
      {Array.from({ length: itemCount }).map((_, index) => (
        <Card className={cn("mb-8", cardLayout)} key={index}>
          <CardHeader className="flex flex-row gap-4">
            <CardTitle>
              <Skeleton className="h-10 w-52 rounded-2xl md:w-80" />
            </CardTitle>
          </CardHeader>
          <CardContent>
            <Skeleton className="h-32 rounded-2xl" />
          </CardContent>
          <CardFooter className="flex flex-col gap-2">
            <Button
              color="primary"
              isLoading={true}
              className="w-full rounded-[20px]"
            >
              Show code
            </Button>
          </CardFooter>
        </Card>
      ))}
    </>
  );
}



================================================
FILE: frontend/src/components/ui/badge.tsx
================================================
import { cva, VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };



================================================
FILE: frontend/src/components/ui/button.tsx
================================================
import { cva, VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";
import { Slot } from "@radix-ui/react-slot";

export const linkButtonStyle =
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium text-black underline-offset-4 transition-colors hover:underline focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };



================================================
FILE: frontend/src/components/ui/card.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      // FIXME: maybe better card bg-color
      "rounded-xl bg-white text-card-foreground drop-shadow-lg",
      className,
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};



================================================
FILE: frontend/src/components/ui/drawer.tsx
================================================
"use client";

import * as React from "react";
import { Drawer as DrawerPrimitive } from "vaul";

import { cn } from "@/lib/utils";

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
);
Drawer.displayName = "Drawer";

const DrawerTrigger = DrawerPrimitive.Trigger;

const DrawerPortal = DrawerPrimitive.Portal;

const DrawerClose = DrawerPrimitive.Close;

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
));
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName;

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className,
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
));
DrawerContent.displayName = "DrawerContent";

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
);
DrawerHeader.displayName = "DrawerHeader";

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
);
DrawerFooter.displayName = "DrawerFooter";

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
DrawerTitle.displayName = DrawerPrimitive.Title.displayName;

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DrawerDescription.displayName = DrawerPrimitive.Description.displayName;

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
};



================================================
FILE: frontend/src/components/ui/input.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };



================================================
FILE: frontend/src/components/ui/label.tsx
================================================
"use client";

import { cva, VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";
import * as LabelPrimitive from "@radix-ui/react-label";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };



================================================
FILE: frontend/src/components/ui/scroll-area.tsx
================================================
"use client";

import * as React from "react";

import { cn } from "@/lib/utils";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className,
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };



================================================
FILE: frontend/src/components/ui/select.tsx
================================================
"use client";

import * as React from "react";

import { cn } from "@/lib/utils";
import {
  CaretSortIcon,
  CheckIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from "@radix-ui/react-icons";
import * as SelectPrimitive from "@radix-ui/react-select";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <CaretSortIcon className="size-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronUpIcon />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronDownIcon />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <CheckIcon className="size-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};



================================================
FILE: frontend/src/components/ui/sheet.tsx
================================================
"use client";

import { cva, VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";
import * as SheetPrimitive from "@radix-ui/react-dialog";
import { Cross2Icon } from "@radix-ui/react-icons";

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 p-4 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <Cross2Icon className="size-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className,
    )}
    {...props}
  />
);
SheetHeader.displayName = "SheetHeader";

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className,
    )}
    {...props}
  />
);
SheetFooter.displayName = "SheetFooter";

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};



================================================
FILE: frontend/src/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  );
}

export { Skeleton };



================================================
FILE: frontend/src/components/ui/textarea.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Textarea.displayName = "Textarea";

export { Textarea };



================================================
FILE: frontend/src/components/ui/toast.tsx
================================================
"use client";

import { cva, VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";
import { Cross2Icon } from "@radix-ui/react-icons";
import * as ToastPrimitives from "@radix-ui/react-toast";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed bottom-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-bottom-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className,
    )}
    toast-close=""
    {...props}
  >
    <Cross2Icon className="size-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};



================================================
FILE: frontend/src/components/ui/toaster.tsx
================================================
"use client";

import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}



================================================
FILE: frontend/src/components/ui/use-toast.ts
================================================
"use client";

// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t,
        ),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };



================================================
FILE: frontend/src/hooks/useTitle.tsx
================================================
import { useEffect } from "react";

function useTitle(title: string) {
  useEffect(() => {
    document.title = `${title} - CodeStash`;
  }, [title]);
}
export default useTitle;



================================================
FILE: frontend/src/lib/utils.ts
================================================
import { ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}



================================================
FILE: frontend/src/store/userStore.ts
================================================
import { queryClient } from "@/app/providers";
import fetcher, { axiosInstance } from "@/utils/axios";
import toast from "react-hot-toast";
import { create } from "zustand";

interface UserState {
  isLoggedIn: boolean;
  showProfileCard: boolean;
  setShowProfileCard: (state: boolean) => void;
  userData: null | {
    _id: string;
    firstName: string;
    lastName: string;
    email: string;
    username: string;
    madeBy: {
      fullName: string;
      _id: string;
    };
    avatar: string;
    upvotedPosts: string[];
    downvotedPosts: string[];
    upvotedComments: string[];
    downvotedComments: string[];
    savedPosts: string[];
    communitiesJoined: string[];
    verifyCode?: string;
    verifyCodeExpiry?: Date;
    isVerified: boolean;
    downloadPath: string;
  };
  setUserData: (userData: UserState["userData"]) => void;
  getCurrentUser: () => Promise<void>;
  registerUser: ({
    firstName,
    lastName,
    email,
    password,
  }: {
    firstName: string;
    lastName: string;
    email: string;
    password: string;
  }) => void;
  loginUser: ({ email, password }: { email: string; password: string }) => void;
  logoutUser: () => void;
  upvotePost: (postId: string) => void;
  downvotePost: (postId: string) => void;
  upvoteComment: (commentId: string) => void;
  downvoteComment: (commentId: string) => void;
  joinCommunity: (name: string) => void;
  leaveCommunity: (name: string) => void;
  savePost: (postId: string) => void;
  removeSavedPost: (postId: string) => void;
}

export const useUserStore = create<UserState>()((set, get) => ({
  isLoggedIn: false,
  showProfileCard: false,
  setShowProfileCard: (state) => {
    set(() => ({ showProfileCard: state }));
  },
  userData: null,
  setUserData: (userData) => {
    set(() => ({ userData }));
  },
  getCurrentUser: () => {
    return axiosInstance
      .get("/users/get-current-user")
      .then((res) => {
        set(() => ({ userData: res.data.data.user }));
        set(() => ({ isLoggedIn: true }));
        set(() => ({ showProfileCard: true }));
      })
      .catch((error) => {
        if (error.status === 401) {
          console.log("error 401");
        }
      });
  },
  registerUser: async ({ firstName, lastName, email, password }) => {
    toast.loading("Signing up...", { id: "register" });

    await fetcher
      .post("/users/register", {
        firstName,
        lastName,
        email,
        password,
      })
      .then(() => {
        toast.success("Sign up successful", { id: "register" });
        get().loginUser({ email, password });
      })
      .catch((err) => {
        switch (err.response.status) {
          case 409:
            toast.error("User already exists", { id: "register" });
            break;
          default:
            toast.error("Something went wrong", { id: "register" });
            break;
        }
      });
  },
  loginUser: async ({ email, password }) => {
    toast.loading("Logging in...", { id: "login" });

    await fetcher
      .post("/users/login", { email, password })
      .then((res) => {
        set(() => ({ userData: res.user }));
        set(() => ({ isLoggedIn: true }));
        set(() => ({ showProfileCard: true }));
        toast.success("Logged in successfully", { id: "login" });
      })
      .catch((err) => {
        switch (err.response.status) {
          case 401:
            toast.error("Invalid email or password", { id: "login" });
            break;
          case 404:
            toast.error("User not found", { id: "login" });
            break;
          default:
            toast.error("Something went wrong", { id: "login" });
            break;
        }
      });
  },
  logoutUser: () => {
    const logoutToastPromise = fetcher.post("/users/logout").then(() => {
      set(() => ({ isLoggedIn: false }));
      set(() => ({ userData: null }));
      set(() => ({ showProfileCard: false }));
    });

    toast.promise(logoutToastPromise, {
      loading: "Logging out...",
      success: "Logged out successfully",
      error: "Failed to logout",
    });
  },
  upvotePost: async (postId) => {
    await fetcher.patch(`/posts/upvote`, { postId }).then((res) => {
      set(() => ({ userData: res.user }));
      queryClient.invalidateQueries({ queryKey: [postId] });
      queryClient.invalidateQueries({ queryKey: ["upvoted-posts"] });
      queryClient.invalidateQueries({ queryKey: ["downvoted-posts"] });
    });
  },
  downvotePost: async (postId) => {
    await fetcher.patch(`/posts/downvote`, { postId }).then((res) => {
      set(() => ({ userData: res.user }));
      queryClient.invalidateQueries({ queryKey: [postId] });
      queryClient.invalidateQueries({ queryKey: ["upvoted-posts"] });
      queryClient.invalidateQueries({ queryKey: ["downvoted-posts"] });
    });
  },
  upvoteComment: async (commentId) => {
    await fetcher.patch(`/comments/upvote`, { commentId }).then((res) => {
      set(() => ({ userData: res.user }));
    });
  },
  downvoteComment: async (commentId) => {
    await fetcher.patch(`/comments/downvote`, { commentId }).then((res) => {
      set(() => ({ userData: res.user }));
    });
  },
  joinCommunity: (name) => {
    const joinCommunityPromise = fetcher
      .post("/community/join", { community: name })
      .then((res) => {
        console.log(res);
        set(() => ({ userData: res.user }));
      });

    toast.promise(joinCommunityPromise, {
      loading: `Joining c/${name}`,
      success: `Joined c/${name} successfully`,
      error: `Failed to join c/${name}`,
    });
  },
  leaveCommunity: (name) => {
    const leaveCommunityPromise = fetcher
      .post("/community/leave", { community: name })
      .then((res) => {
        set(() => ({ userData: res.user }));
      });

    toast.promise(leaveCommunityPromise, {
      loading: `Leaving c/${name}`,
      success: `Left c/${name} successfully`,
      error: `Failed to leave c/${name}`,
    });
  },
  savePost: (postId) => {
    const savePostToastPromise = fetcher
      .post("/posts/save", { postId })
      .then((res) => {
        set(() => ({ userData: res.user }));
        queryClient.invalidateQueries({ queryKey: ["saved-posts"] });
      });

    toast.promise(savePostToastPromise, {
      loading: "Saving post...",
      success: "Saved post successfully",
      error: "Error saving post",
    });
  },
  removeSavedPost: (postId) => {
    const removeSavedPostPromise = fetcher
      .patch("/posts/remove-saved-post", { postId })
      .then((res) => {
        set(() => ({ userData: res.user }));
        queryClient.invalidateQueries({ queryKey: ["saved-posts"] });
      });

    toast.promise(removeSavedPostPromise, {
      loading: "Removing post from saved...",
      success: "Removed post from saved",
      error: "Error removing post from saved",
    });
  },
}));



================================================
FILE: frontend/src/types/commentTypes.ts
================================================
export type Comment = {
  _id: string;
  madeBy: {
    userId: string;
    username: string;
  };
  parent: string;
  type: "comment" | "reply";
  content: string;
  upvotes: number;
  downvotes: number;
  isEdited: boolean;
};



================================================
FILE: frontend/src/types/postTypes.ts
================================================
export type PostTypes = {
  _id: string;
  title: string;
  content: string;
  description: string;
  madeBy: { userId: string; fullname: string; username: string };
  upvotes: number;
  downvotes: number;
  language: string;
  community: string;
};



================================================
FILE: frontend/src/types/userTypes.ts
================================================
export type UserTypes = {
  _id: string;
  firstName: string;
  lastName: string;
  email: string;
  username: string;
  madeBy: {
    fullName: string;
    _id: string;
  };
  avatar: string;
  upvotedPosts: string[];
  downvotedPosts: string[];
  upvotedComments: string[];
  downvotedComments: string[];
  savedPosts: string[];
  communitiesJoined: string[];
  verifyCode?: string;
  verifyCodeExpiry?: Date;
  isVerified: boolean;
  downloadPath: string;
};



================================================
FILE: frontend/src/utils/axios.ts
================================================
import axios from "axios";

export const axiosInstance = axios.create({
  baseURL: `${process.env.NEXT_PUBLIC_BACKEND_URL}/api`,
  withCredentials: true,
});

const fetcher = {
  get: async (url: string, options = {}) => {
    const response = await axiosInstance(url, options);
    return response.data.data;
  },
  post: async (url: string, options = {}) => {
    const response = await axiosInstance.post(url, options);
    return response.data.data;
  },
  put: async (url: string, options = {}) => {
    const response = await axiosInstance.put(url, options);
    return response.data.data;
  },
  patch: async (url: string, options = {}) => {
    const response = await axiosInstance.patch(url, options);
    return response.data.data;
  },
  delete: async (url: string) => {
    const response = await axiosInstance.delete(url);
    return response.data.data;
  },
};

export default fetcher;



================================================
FILE: frontend/src/utils/classnames.tsx
================================================
import { useUserStore } from "@/store/userStore";
// export const cardLayout = "w-[90vw] max-w-[700px] md:w-[60vw]";
// export const cardLayout = "max-w-[630px] xl:max-w-full xl:mr-10";

export const cardLayout = `${useUserStore.getState().showProfileCard ? "max-w-[700px]" : "max-w-full"} lg:mr-8`;
export const nextblue = "bg-[#c7d7fc]";



================================================
FILE: frontend/src/utils/constants.ts
================================================
import toast from "react-hot-toast";

export const allowedLanguages = [
  "javascript",
  "python",
  "typescript",
  "ruby",
  "java",
  "cpp",
  "go",
  "php",
  "swift",
] as const;

export const infoToast = (toastMessage: string) => {
  toast.error(toastMessage, { icon: "ğŸ“Œ" });
};



================================================
FILE: frontend/src/utils/get-query-client.ts
================================================
import {
  QueryClient,
  defaultShouldDehydrateQuery,
  isServer,
} from "@tanstack/react-query";

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
      dehydrate: {
        // include pending queries in dehydration
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) ||
          query.state.status === "pending",
      },
    },
  });
}

let browserQueryClient: QueryClient | undefined = undefined;

export function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient();
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}



================================================
FILE: frontend/.husky/pre-commit
================================================
# Pre commits are stopped for now
# #!/bin/sh
# cd frontend

# # Check if there are any changes in the frontend directory
# if git diff --cached --name-only | grep -q '^frontend/src/'; then
#   # linting
#   pnpm run lint || {
#     echo "Linting failed. Commit aborted."
#     exit 1

#   }
#   # formatting
#   pnpm run format || {
#     echo "Formatting failed. Commit aborted."
#     exit 1
#   }

#   # adding the formatted changes
#   git add .
# else
#   echo "No changes in the frontend directory. Skipping linting and formatting."
# fi


